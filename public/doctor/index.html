<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NodeJS</title>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.1/dist/js.cookie.min.js"></script>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<a href="/doctor/index.html">Nodejs</a> &nbsp; 
<a href="/doctor/react.html">React</a> &nbsp; 
<a href="/doctor/docker.html">Docker</a> &nbsp; 
<a href="/doctor/cmd.html">CMD</a> &nbsp; 
<a href="/doctor/kafka.html">Kafka</a> &nbsp; 
<a href="kafka-interview.html">Kafka Interview</a> &nbsp; 
<a href="mongodb.html">Mongo DB</a> &nbsp; 
<a href="code.html">Promise</a> &nbsp; 
<a href="coding.html">Coding</a> &nbsp; 
<a href="https://onecompiler.com/nodejs/43hqq7r87" target="_blank">Coding</a> &nbsp; 

<ul class="faq">
<li data-id="q122"><span class="faq-question">
Node.js?
</span><div class="answer">
Node.js is an open-source, cross-platform runtime built on Chrome’s V8 JavaScript engine that allows JavaScript to run outside the browser. It’s designed for building scalable, event-driven, non-blocking I/O applications, commonly used for servers and APIs.
<br />

Indexing
Async / await ?
CICD : workflow
CROS
sequlize
MySQL
TypeScript
nestjs 
tailwind

</div></li>



<li data-id="q_redux_formatted"><span class="faq-question">
  Redux
  </span><div class="answer">
  <strong>Redux</strong> is a state management library often used with React for building user interfaces. It provides a centralized store for managing the application's state, making it predictable and maintainable.


  <ol class="subul">
  <li><strong>Store:</strong> The single source of state data that holds the entire state data of the application.</li>
  <li><strong>Actions:</strong> Plain JavaScript objects that describe an event that occurred. Every action must have a type field.</li>
  <li><strong>Reducers:</strong> A pure function that takes the current state and an action, and returns a new state based on the action type.</li>
  <li><strong>Dispatch:</strong> A method to send actions to the reducer to update the state.</li>
  <li><strong>Subscription:</strong> Listeners that get called whenever the state changes. </li>
  </ol>

  <br><strong>React Redux:</strong> is the official React binding for Redux. It allows React components to interact with the Redux store.
  <ol class="subul">
  <li><strong>Provider:</strong> Makes the Redux store available to the app.</li>
  <li><strong>useSelector:</strong> Hook to read data from the store.</li>
  <li><strong>useDispatch:</strong> Hook to dispatch actions to the store.</li>
  </ol>

  <br><strong>How It Works:</strong>
  <ol class="subul">
  <li>A component dispatches an action.</li>
  <li>The action is sent to a reducer.</li>
  <li>The reducer updates the state based on the action.</li>
  <li>Subscribed components are notified and re-render with new data.</li>
  </ol>

  <br><strong>Redux Toolkit:</strong>
  The recommended way to write Redux logic, simplifying store setup, reducers, and immutable updates.

  <br><br><strong>Benefits:</strong>
  <ul class="subul">
  <li>Centralized State Management</li>
  <li>Predictable State Updates</li>
  <li>Improved Debugging</li>
  <li>Performance Optimization</li>
  </ul>

  <br><strong>Use Cases:</strong><br>
  Redux is best suited for large, complex applications with shared state. For simpler apps, React's Context API may be enough.
  </div></li>
  <li data-id="q_redux_example"><span class="faq-question">
    Redux Example ***
    </span><div class="answer">
    Here's a simple example of Redux in a React application:
    
    <br><br><strong>1. Install Redux:</strong><br>
    <code>npm install redux react-redux</code>
    
    <br><br><strong>2. Create Action:</strong><br>
    <pre><code>
    // actions.js
    export const increment = () =&gt; ({ type: 'INCREMENT' });
    </code></pre>
    
    <br><strong>3. Create Reducer:</strong><br>
    <pre><code>
    // reducer.js
    const counterReducer = (state = 0, action) =&gt; {
      switch (action.type) {
        case 'INCREMENT':
          return state + 1;
        default:
          return state;
      }
    };
    export default counterReducer;
    </code></pre>
    
    <br><strong>4. Create Store:</strong>
    <pre><code>
    // store.js
    import { createStore } from 'redux';
    import counterReducer from './reducer';
    const store = createStore(counterReducer);
    export default store;
    </code></pre>
    
    <br><strong>5. Provide Store to React:</strong><br>
    <pre><code>
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import { Provider } from 'react-redux';
    import App from './App';
    import store from './store';
    
    ReactDOM.render(
      &lt;Provider store={store}&gt;
        &lt;App /&gt;
      &lt;/Provider&gt;,
      document.getElementById('root')
    );
    </code></pre>
    
    <br><strong>6. Use Redux in Component:</strong><br>
    <pre><code>
    // App.js
    import React from 'react';
    import { useSelector, useDispatch } from 'react-redux';
    import { increment } from './actions';
    
    function App() {
      const count = useSelector(state =&gt; state);
      const dispatch = useDispatch();
    
      return (
        &lt;div&gt;
          &lt;h1&gt;Count: {count}&lt;/h1&gt;
          &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;
        &lt;/div&gt;
      );
    }
    export default App;
    </code></pre>
    
    This sets up a working counter app using Redux.
    </div></li>

    <li data-id="q_redux_middleware"><span class="faq-question">
      Redux Middleware?
      </span><div class="answer">
      Redux middleware is a function that sits between the dispatching of an action and the moment it reaches the reducer. It provides a powerful way to extend Redux with custom functionality such as logging, crash reporting, asynchronous operations (like API calls), etc.
      
      <br><br><strong>How Middleware Works:</strong><br>
      When an action is dispatched, middleware can intercept it, perform tasks (e.g., logging or fetching data), and then pass the action to the reducer.
      
      <br><br><strong>Example:</strong><br>
      <pre><code>
      const loggerMiddleware = store =&gt; next =&gt; action =&gt; {
        console.log('Dispatching:', action);
        return next(action);
      };
      </code></pre>
      
      <br><strong>Apply Middleware:</strong><br>
      <pre><code>
      import { createStore, applyMiddleware } from 'redux';
      const store = createStore(reducer, applyMiddleware(loggerMiddleware));
      </code></pre>
      
      <br><strong>Common Middleware:</strong><br>
      <ul>
        <li><strong>redux-thunk:</strong> For async logic using functions as actions.</li>
        <li><strong>redux-saga:</strong> For complex async flows using generators.</li>
        <li><strong>redux-logger:</strong> For logging actions and state.</li>
      </ul>
      
      Middleware enhances Redux functionality while keeping actions and reducers pure and focused.
      </div></li>
      
      <li data-id="q_redux_thunk"><span class="faq-question">
        Redux-Thunk?
        </span><div class="answer">
        <code>redux-thunk</code> is a middleware for Redux that allows you to write action creators that return a function instead of an action. This function can perform asynchronous operations (like API calls) and then dispatch regular actions based on the result.
        
        <br><br><strong>Why Use redux-thunk?</strong><br>
        Redux only supports synchronous data flow by default. To handle async operations like fetching data, you need middleware like <code>redux-thunk</code>.
        
        <br><br><strong>Installation:</strong><br>
        <code>npm install redux-thunk</code>
        
        <br><br><strong>Apply Thunk Middleware:</strong><br>
        <pre><code>
        import { createStore, applyMiddleware } from 'redux';
        import thunk from 'redux-thunk';
        const store = createStore(reducer, applyMiddleware(thunk));
        </code></pre>
        
        <br><strong>Example Usage:</strong><br>
        <pre><code>
        const fetchUser = () =&gt; {
          return dispatch =&gt; {
            dispatch({ type: 'USER_FETCH_REQUEST' });
            fetch('/api/user')
              .then(res =&gt; res.json())
              .then(data =&gt; dispatch({ type: 'USER_FETCH_SUCCESS', payload: data }))
              .catch(error =&gt; dispatch({ type: 'USER_FETCH_FAILURE', error }));
          };
        };
        </code></pre>
        
        <br>With <code>redux-thunk</code>, you can delay the dispatch of an action or dispatch only if a certain condition is met, enabling more flexible and powerful Redux logic.
        </div></li>
        
        <li data-id="q_redux_saga"><span class="faq-question">
          Redux-Saga?
          </span><div class="answer">
          Redux-Saga is a middleware library for Redux that manages side effects like asynchronous data fetching and impure things (e.g., accessing browser cache). It uses ES6 generator functions to make async flows easier to read, write, and test.
          
          <br><br><strong>How Redux-Saga Works:</strong><br>
          Sagas listen for dispatched actions and run generator functions (“sagas”) that yield effects, such as calling APIs or dispatching other actions.
          
          <br><br><strong>Benefits:</strong><br>
          <ul>
            <li>Better handling of complex async logic and side effects</li>
            <li>Easy to test due to generator functions</li>
            <li>Declarative effects make flow control simpler</li>
          </ul>
          
          <br><strong>Basic Example:</strong><br>
          <pre><code>
          import { takeEvery, call, put } from 'redux-saga/effects';
          
          function* fetchUser(action) {
            try {
              const data = yield call(fetch, '/api/user');
              const user = yield data.json();
              yield put({ type: 'USER_FETCH_SUCCESS', payload: user });
            } catch (e) {
              yield put({ type: 'USER_FETCH_FAILURE', error: e.message });
            }
          }
          
          function* watchFetchUser() {
            yield takeEvery('USER_FETCH_REQUEST', fetchUser);
          }
          </code></pre>
          
          Redux-Saga offers powerful control over side effects and concurrency in Redux apps.
          </div></li>
          
          <li data-id="q_redux_logger"><span class="faq-question">
            Redux-Logger?
            </span><div class="answer">
            <code>redux-logger</code> is a middleware for Redux that logs actions and state changes to the console. It helps developers debug by showing detailed information about every dispatched action and how the state updates.
            
            <br><br><strong>How it works:</strong><br>
            When an action is dispatched, redux-logger prints the previous state, the action, and the next state in a formatted and readable way.
            
            <br><br><strong>Installation:</strong><br>
            <code>npm install redux-logger</code>
            
            <br><br><strong>Setup Example:</strong><br>
            <pre><code>
            import { createStore, applyMiddleware } from 'redux';
            import logger from 'redux-logger';
            const store = createStore(reducer, applyMiddleware(logger));
            </code></pre>
            
            <br><strong>Benefits:</strong><br>
            <ul>
              <li>Helps track dispatched actions in real-time</li>
              <li>Shows state changes clearly for easier debugging</li>
              <li>Useful in development but should be disabled in production</li>
            </ul>
            </div></li>
            
            <li data-id="q_sql_normalization"><span class="faq-question">
              SQL Normalization?
              </span><div class="answer">
              SQL Normalization is a database design technique that organizes tables to reduce data redundancy and improve data integrity. It divides large tables into smaller, related tables and defines relationships between them.
              
              <br><br><strong>Normalization Forms:</strong><br>
              <ol class="subul">
                <li><strong>1NF (First Normal Form):</strong> Eliminate duplicate columns, ensure atomic values.</li>
                <li><strong>2NF (Second Normal Form):</strong> Remove partial dependencies on primary key.</li>
                <li><strong>3NF (Third Normal Form):</strong> Remove transitive dependencies.</li>
                <li><strong>BCNF (Boyce-Codd Normal Form):</strong> A stricter version of 3NF.</li>
              </ol>
              
              <br><strong>Benefits:</strong><br>
              - Avoids data duplication<br>
              - Maintains data consistency<br>
              - Simplifies data maintenance and updates<br>
              
              Normalization helps design efficient, reliable, and scalable relational databases.
              </div></li>
              
              <li data-id="q_redis"><span class="faq-question">
                Redis DB and What Are Its Uses?
                </span><div class="answer">
                <strong>Redis</strong> (Remote Dictionary Server) is an open-source, in-memory data store used as a database, cache, and message broker. It supports various data structures like strings, hashes, lists, sets, and sorted sets.
                
                <br><br><strong>Key Features:</strong><br>
                - Extremely fast (in-memory storage)<br>
                - Supports persistence (RDB, AOF)<br>
                - Pub/Sub messaging system<br>
                - Built-in replication and clustering<br>
                
                <br><strong>Common Uses:</strong><br>
                <ol class="subul">
                  <li><strong>Caching:</strong> Speeds up web apps by caching frequently accessed data.</li>
                  <li><strong>Session Store:</strong> Stores user sessions for fast access in scalable applications.</li>
                  <li><strong>Real-time Analytics:</strong> Useful for counters, leaderboard rankings, etc.</li>
                  <li><strong>Message Queues:</strong> Implements lightweight queues using lists or Pub/Sub.</li>
                  <li><strong>Rate Limiting:</strong> Controls API usage with time-based counters.</li>
                </ol>
                
                Redis is widely used for high-performance applications that require low-latency data access.
                </div></li>
                














              <li data-id="q3"><span class="faq-question">---------------------------------------</span><br /><span class="faq-question">---------------------------------------</span></li>    


<li data-id="q_promise"><span class="faq-question">
Promise?
</span><div class="answer">
A <strong>Promise</strong> is an object representing the eventual completion or failure of an asynchronous operation. <br />
It has 3 states: 
<ol>
  <li>pending</li>
  <li>fulfilled</li>
  <li>rejected</li>
</ol>


Basic usage:
<pre><code>
const promise = new Promise((resolve, reject) => {
setTimeout(() => resolve("Done!"), 1000);
});

promise.then(result => console.log(result)).catch(err => console.error(err));
</code></pre>

<strong>Advanced Promise Topics:</strong><br>
• <code>Promise.all()</code>: Waits for all promises to resolve or any to reject.<br>
• <code>Promise.race()</code>: Resolves/rejects as soon as one of the promises does.<br>
• <code>Promise.allSettled()</code>: Waits for all promises to settle (resolve or reject).<br>
• <code>Promise.any()</code>: Resolves as soon as one promise fulfills (ignores rejections).<br>
• <code>Chaining</code>: Linking multiple <code>.then()</code> calls for sequential execution.<br>
• <code>Error handling</code>: Using <code>.catch()</code> and <code>finally()</code> for robust flows.<br>
• <code>Async/Await</code>: Syntactic sugar over promises for cleaner asynchronous code.<br><br>

Mastering Promises is essential for handling async operations in modern JavaScript.


<hr />
<pre><code>
    // Sample async function returning a promise
    const delay = (time, value, shouldReject = false) => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          shouldReject ? reject(`Error: ${value}`) : resolve(value);
        }, time);
      });
    };

    // 1. Promise.all
    Promise.all([
      delay(1000, 'A'),
      delay(1500, 'B'),
      delay(500, 'C')
    ]).then(results => {
      console.log('Promise.all:', results); // ['A', 'B', 'C']
    }).catch(err => {
      console.error('Promise.all error:', err);
    });

    // 2. Promise.race
    Promise.race([
      delay(1000, 'X'),
      delay(500, 'Y'),
      delay(2000, 'Z')
    ]).then(result => {
      console.log('Promise.race:', result); // 'Y'
    }).catch(err => {
      console.error('Promise.race error:', err);
    });

    // 3. Promise.allSettled
    Promise.allSettled([
      delay(1000, 'Success1'),
      delay(800, 'Fail1', true),
      delay(1200, 'Success2')
    ]).then(results => {
      console.log('Promise.allSettled:', results);
    });

    // 4. Promise.any
    Promise.any([
      delay(1000, 'Pass1', true),
      delay(800, 'Pass2', true),
      delay(1200, 'Winner')
    ]).then(result => {
      console.log('Promise.any:', result); // 'Winner'
    }).catch(err => {
      console.error('Promise.any error:', err); // Only if all fail
    });

    // 5. Chaining with .then()
    delay(1000, 'Start')
      .then(result => {
        console.log('Chaining 1:', result);
        return delay(1000, 'Step 2');
      })
      .then(result => {
        console.log('Chaining 2:', result);
        return delay(1000, 'Step 3');
      })
      .then(result => {
        console.log('Chaining 3:', result);
      });

    // 6. Error handling
    delay(1000, 'Oops', true)
      .then(result => {
        console.log('Will not run:', result);
      })
      .catch(error => {
        console.error('Caught error:', error); // 'Error: Oops'
      });

    </code></pre>



</div></li>

<li data-id="q_hoisting"><span class="faq-question">
Hoisting?
</span><div class="answer">
Hoisting is JavaScript's default behavior of moving declarations to the top of their scope before code execution. It applies to <code>var</code> declarations and function declarations.

Variables declared with <code>var</code> are hoisted and initialized with <code>undefined</code>, whereas <code>let</code> and <code>const</code> are hoisted but not initialized (they are in a "temporal dead zone" until declaration).

Example:
<pre><code>
console.log(x); // undefined
var x = 5;

foo(); // Works
function foo() {
console.log("Hello");
}
</code></pre>
Hoisting can lead to unexpected results if not understood properly.
</div></li>



<li data-id="q_closure"><span class="faq-question">
Closure?
</span><div class="answer">
A closure in Node.js (and JavaScript) is a function that "remembers" its lexical scope even when executed outside of that scope. It allows inner functions to access variables from their outer function even after the outer function has returned.

Closures are useful for data encapsulation, private variables, and maintaining state between function calls.

Example:
<pre><code>
function outer() {
let count = 0;
return function inner() {
count++;
return count;
};
}
const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
</code></pre>
Here, <code>count</code> persists because of closure.
</div></li>




<li data-id="q_middleware_interceptor_filter"><span class="faq-question">
Middleware Vs Interceptor Vs Filter?
</span><div class="answer">
<strong>Middleware</strong>, <strong>Interceptor</strong>, and <strong>Filter</strong> are all mechanisms for handling requests/responses, but they differ by context and use-case:
<br />
<strong>Middleware (Express.js/Node.js):</strong><br>
- Functions executed before reaching route handlers.<br>
- Used for logging, authentication, parsing, etc.<br>
- Can modify request/response objects.<br>
- Example:
<pre><code>
app.use((req, res, next) => {
console.log('Middleware');
next();
});
</code></pre>

<strong>Interceptor (NestJS, Angular, etc.):</strong><br>
- Wraps around method execution (before & after).<br>
- Often used to modify input/output, add headers, transform responses.<br>
- Ideal for logging, caching, error handling.<br>

<strong>Filter (NestJS, Java, etc.):</strong><br>
- Specifically handles exceptions/errors.<br>
- Catches thrown errors and returns formatted responses.<br>
- Ideal for global error responses, logging exceptions.
<br /><br />
<strong>Summary:</strong><br>
- <strong>Middleware</strong>: Handles requests early (e.g., auth, body parsing).<br>
- <strong>Interceptor</strong>: Wraps execution, ideal for transforming results or adding behaviors.<br>
- <strong>Filter</strong>: Catches and handles exceptions.
</div></li>

<li data-id="q_guards_vs_auth"><span class="faq-question">
Guards Vs Authentication? JWT
</span><div class="answer">
<strong>Authentication</strong> and <strong>Guards</strong> are both related to security but serve different purposes:
<Br />
<strong>Authentication:</strong><br>
- The process of verifying a user's identity (e.g., via username/password, token).<br>
- Determines “Who are you?”<br>
- Implemented using strategies like JWT, OAuth, sessions, etc.<br>
- Example: Decoding a JWT token to validate a user.
<Br />
<strong>Guards (e.g., in NestJS):</strong><br>
- A mechanism to protect routes based on authentication or authorization logic.<br>
- Executes before a route is handled.<br>
- Determines “Are you allowed to access this?”<br>
- Used to allow/deny access to certain endpoints based on roles, permissions, or login status.
<Br />
<strong>Summary:</strong><br>
- <strong>Authentication</strong> confirms user identity.<br>
- <strong>Guards</strong> control access after authentication.

<hr />

  <h4>Common JWT Security Mistakes :<br /> jwt.sign(payload, secret, { algorithm: 'HS256' });</h4>

  <div class="mistake">
    <strong>1. Use <code>none</code> as the algorithm (Never do this!)</strong><br>
    Attackers can forge tokens if verification is bypassed.
    <div class="tip">✅ Always validate the algorithm and enforce a known one like <code>HS256</code> or <code>RS256</code>.</div>
  </div>

  <div class="mistake">
    <strong>2. Store JWTs in <code>localStorage</code></strong><br>
    Vulnerable to XSS attacks.
    <div class="tip">✅ Prefer <code>HttpOnly</code> cookies when possible.</div>
  </div>

  <div class="mistake">
    <strong>3. Don’t Set Expiration (<code>exp</code>)</strong><br>
    Tokens without expiry can be used indefinitely.
    <div class="tip">✅ Always set an expiry like <code>1h</code>, <code>15m</code>, etc.</div>
  </div>

  <div class="mistake">
    <strong>4. Exposing the secret key</strong><br>
    If your secret key leaks, all tokens are compromised.
    <div class="tip">✅ Keep secrets safe using environment variables or secure secret managers.</div>
  </div>

  <div class="mistake">
    <strong>5. Not using HTTPS</strong><br>
    JWTs sent over HTTP can be intercepted.
    <div class="tip">✅ Always use <code>HTTPS</code> to prevent MITM (Man-In-The-Middle) attacks.</div>
  </div>






</div></li>

<li data-id="q_dependency_injection"><span class="faq-question">
Dependency Injection (DI)?
</span><div class="answer">
<strong>Dependency Injection (DI)</strong> is a design pattern where an object or function receives its dependencies from an external source rather than creating them internally.

It promotes loose coupling, testability, and better code structure.
<br /><br />
In frameworks like <strong>NestJS</strong>, DI is a core feature. Services, repositories, or other providers are injected into classes (like controllers) through constructors.

Example (NestJS):
<pre><code>
@Injectable()
export class UserService {
constructor(private readonly userRepo: UserRepository) {}
}
</code></pre>

Here, <code>UserRepository</code> is automatically injected by NestJS’s DI container.

DI improves modularity, makes mocking easy for testing, and encourages best practices.
</div></li>


<li data-id="q_decorator"><span class="faq-question">
a Decorator in TypeScript?
</span><div class="answer">
A <strong>decorator</strong> is a special kind of declaration in TypeScript that can be attached to classes, methods, properties, or parameters to modify their behavior at runtime.

Decorators are functions prefixed with <code>@</code> and are widely used in frameworks like <strong>NestJS</strong> and <strong>Angular</strong>.

Types of decorators:
- <strong>Class Decorators</strong>
- <strong>Method Decorators</strong>
- <strong>Property Decorators</strong>
- <strong>Parameter Decorators</strong>

Example:
<pre><code>
function Logger(constructor: Function) {
console.log("Class created:", constructor.name);
}

@Logger
class MyClass {}
</code></pre>

In NestJS:
<pre><code>
@Controller('users')
export class UserController {}
</code></pre>

Decorators add metadata or change behavior, helping with clean and declarative code.
</div></li>
<li data-id="q_get_decorator"><span class="faq-question">
Is @Get() a decorator in NestJS?
</span><div class="answer">
Yes, <code>@Get()</code> is a method decorator in <strong>NestJS</strong> used to define a route handler for HTTP GET requests. It is part of the <code>@nestjs/common</code> package and maps the decorated method to a specific endpoint.

Example:
<pre><code>
@Controller('users')
export class UserController {
@Get()
findAll() {
return ['user1', 'user2'];
}

@Get(':id')
findOne(@Param('id') id: string) {
return `User ${id}`;
}
}
</code></pre>

Here:
- <code>@Get()</code> maps to <code>/users</code>
- <code>@Get(':id')</code> maps to <code>/users/:id</code>

These decorators help build clean, declarative REST APIs.
</div></li>

<li data-id="q_module_decorator"><span class="faq-question">
Is @Module() a decorator in NestJS?
</span><div class="answer">
Yes, <code>@Module()</code> is a class decorator in NestJS. It defines a module, which is a fundamental building block organizing related components like controllers, providers, and imports.

Example:
<pre><code>
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
controllers: [UsersController],
providers: [UsersService],
imports: [],
})
export class UsersModule {}
</code></pre>

The <code>@Module()</code> decorator accepts metadata that tells NestJS how to assemble the module, enabling dependency injection and modular architecture.
</div></li>



<li data-id="q_node_event"><span class="faq-question green">
Event? EventEmitter
</span><div class="answer">
In Node.js, an event is a signal emitted by objects to indicate that something has happened, such as a user action or system occurrence. <br />
Node uses the class to handle events, allowing objects to emit named events and listeners to respond asynchronously.  <br /> <br />
This event-driven architecture enables efficient, non-blocking I/O operations, making Node.js suitable for scalable applications.

<pre><code>
const EventEmitter = require('events');
const emitter = new EventEmitter();

emitter.on('message', (data) =&gt; console.log('Received:', data));
emitter.emit('message', 'Hello Node.js!');
</code></pre>
</div></li>

<li data-id="q_event_driven"><span class="faq-question">
Event-Driven Programming?
</span><div class="answer">
Event-driven programming is a design paradigm where the flow of the program is determined by events like user actions, messages, or I/O operations. In Node.js, this model allows the application to respond asynchronously to events using the <code>EventEmitter</code> class. It enables non-blocking I/O by listening for events and executing callbacks when events occur, improving scalability and performance.

This approach helps Node.js efficiently handle multiple operations concurrently without waiting, making it ideal for real-time apps and servers.
</div></li>


<li data-id="q2"><span class="faq-question green">
Event loop?
</span><div class="answer">
The event loop is a mechanism that handles asynchronous callbacks. <br />
It allows Node.js to perform non-blocking I/O operations by offloading tasks to the system kernel and executing their callbacks when ready, enabling efficient single-threaded concurrency.
</div></li>


<li data-id="q22"><span class="faq-question">
Event loop phases?
</span><div class="answer">
Phases include:  
1. timers  
2. pending callbacks  
3. idle/prepare  
4. poll  
5. check (for `setImmediate`)  
6. close callbacks  
Each handles specific queued callbacks.
</div></li>

<li data-id="q9"><span class="faq-question">
Handle concurrency if it's single-threaded?
</span><div class="answer">
Node.js uses the event loop and asynchronous I/O via the libuv library. Heavy tasks are delegated to worker threads or the OS, enabling multiple tasks to be processed concurrently.
</div></li>

<li data-id="q5"><span class="faq-question">
Callback?
</span><div class="answer">
A callback is a function passed as an argument to another function. It’s executed after the completion of an asynchronous operation, allowing non-blocking behavior in Node.js.
</div></li>
<li data-id="q8"><span class="faq-question">
Streams?
</span><div class="answer">
Streams are objects for reading or writing data continuously. They include readable, writable, duplex, and transform streams. Streams are memory-efficient and used for processing large data like files.
</div></li>

<li data-id="q13"><span class="faq-question">
Worker threads?
</span><div class="answer">
Worker threads enable running JavaScript in parallel threads. Unlike the main thread, they can handle CPU-intensive tasks without blocking the event loop, improving performance.
</div>
<div class="answer">
Worker threads are a way to run JavaScript code in parallel on multiple threads in Node.js. While Node.js is single-threaded by default (using an event loop), worker threads enable CPU-intensive tasks to be executed without blocking the main event loop, improving performance for compute-heavy operations.

Introduced in Node.js v10.5.0 (stable since v12), the <code>worker_threads</code> module allows you to create and manage threads that run scripts independently. Each worker has its own event loop, memory, and execution context, enabling true parallelism.

Use cases include heavy computations, data processing, or any synchronous tasks that would otherwise block the main thread and degrade app responsiveness.

Communication between the main thread and worker threads happens via messaging using <code>postMessage()</code> and listening to <code>message</code> events. Workers can share memory efficiently using <code>SharedArrayBuffer</code>.

Example usage:

<pre><code>const { Worker } = require('worker_threads');
const worker = new Worker('./workerScript.js');
worker.on('message', msg =&gt; console.log('From worker:', msg));
worker.postMessage('start');
</code></pre>

Worker threads complement Node.js’s asynchronous model by enabling parallel execution for heavy workloads while maintaining non-blocking I/O in the main thread.
</div></li>
<li data-id="q_package_lock"><span class="faq-question">
Package-lock.json?
</span><div class="answer">
<code>package-lock.json</code> is automatically generated by npm when installing dependencies. It locks the exact versions of installed packages and their sub-dependencies to ensure consistency across different environments. While <code>package.json</code> defines dependency ranges (e.g., <code>^1.2.3</code>), <code>package-lock.json</code> stores the exact versions (e.g., <code>1.2.3</code>) used during installation.<br><br>

This ensures that every developer or deployment environment installs the same dependency tree, avoiding bugs caused by version differences. It also improves performance by caching dependency metadata. This file should be committed to version control in most projects.
</div></li>

<li data-id="q_node_error_handling"><span class="faq-question">
Error handling?
</span><div class="answer">
Error handling in Node.js is critical for building reliable applications. Common strategies include:<br />

<strong>1. Try-Catch:</strong> Used for synchronous code and <code>async/await</code> blocks.
<pre><code>
try {
const data = await getData();
} catch (err) {
console.error(err.message);
}
</code></pre>

<strong>2. Error-First Callbacks:</strong> Standard Node pattern where the first parameter is an error object.
<pre><code>
fs.readFile('file.txt', (err, data) => {
if (err) return console.error(err);
console.log(data.toString());
});
</code></pre>

<strong>3. Global Error Handling:</strong> Catch unhandled exceptions or promise rejections.
<pre><code>
process.on('uncaughtException', (err) => {
console.error('Unhandled Exception:', err);
});
process.on('unhandledRejection', (reason) => {
console.error('Unhandled Rejection:', reason);
});
</code></pre>

<strong>4. Express Middleware:</strong> Use error-handling middleware in Express.
<pre><code>
app.use((err, req, res, next) => {
res.status(500).json({ message: err.message });
});
</code></pre>

Proper error handling helps maintain app stability and improves debugging.
</div></li>

<li data-id="q14oth"><span class="faq-question green">🎯 Abstraction in Object-Oriented Programming (OOP)</h1>
</span><div class="answer">

  <div class="section">
    <h2>What is Abstraction?</h2>
    <p><strong>Abstraction</strong> is the concept of hiding complex implementation details and showing only the essential features of an object.</p>
    <p>It helps reduce complexity by exposing only what is necessary.</p>
  </div>

  <div class="section">
    <h2>Real-World Example</h2>
    <p>When you drive a car, you interact with the steering wheel, pedals, and gear. You don’t need to know how the engine works internally — that's abstraction.</p>
  </div>

  <div class="section">
    <h2>How It Works in OOP</h2>
    <ul>
      <li>Achieved using <strong>abstract classes</strong> and <strong>interfaces</strong>.</li>
      <li>Only relevant operations are exposed through public methods.</li>
      <li>Internal logic is hidden from the user of the object.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Example in Java</h2>
    <pre><code>abstract class Animal {
  abstract void makeSound();
}

class Dog extends Animal {
  void makeSound() {
    System.out.println("Bark");
  }
}

public class Main {
  public static void main(String[] args) {
    Animal a = new Dog();
    a.makeSound();  // Output: Bark
  }
}</code></pre>
    <p>Here, the user of the <code>Animal</code> class knows it has a <code>makeSound()</code> method, but not how it is implemented.</p>
  </div>

  <div class="section">
    <h2>Benefits of Abstraction</h2>
    <ul>
      <li>Improves code readability and maintainability</li>
      <li>Hides unnecessary details from the user</li>
      <li>Supports loose coupling and high cohesion</li>
      <li>Makes the application more secure by exposing only relevant parts</li>
    </ul>
  </div>
  <h1>🔍 Abstraction vs Interface in OOP</h1>

  <div class="section">
    <h2>Definition</h2>
    <p><strong>Abstraction</strong> is the concept of hiding implementation details and exposing only essential features. It can be implemented using <code>abstract classes</code> or <code>interfaces</code>.</p>
    <p><strong>Interface</strong> is a contract that specifies what methods a class should implement, without defining how they are implemented.</p>
  </div>

  <div class="section">
    <h2>Comparison Table</h2>
    <table>
      <thead>
        <tr>
          <th>Feature</th>
          <th>Abstract Class</th>
          <th>Interface</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Purpose</td>
          <td>Used for partial abstraction and shared code.</td>
          <td>Used to define a full contract for implementing classes.</td>
        </tr>
        <tr>
          <td>Method Implementation</td>
          <td>Can have both abstract and concrete methods.</td>
          <td>Cannot have implementation (except default/static in modern languages).</td>
        </tr>
        <tr>
          <td>Multiple Inheritance</td>
          <td>Not supported in many languages (e.g., Java).</td>
          <td>Can implement multiple interfaces.</td>
        </tr>
        <tr>
          <td>Constructors</td>
          <td>Can have constructors.</td>
          <td>Cannot have constructors.</td>
        </tr>
        <tr>
          <td>Access Modifiers</td>
          <td>Can use public, protected, private, etc.</td>
          <td>Methods are public by default.</td>
        </tr>
        <tr>
          <td>Use Case</td>
          <td>When classes share common behavior with differences.</td>
          <td>When you want to enforce a common API without shared code.</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>Example in Java</h2>

    <h3>Abstract Class</h3>
    <pre><code>abstract class Animal {
  abstract void sound();

  void breathe() {
    System.out.println("Breathing...");
  }
}</code></pre>

    <h3>Interface</h3>
    <pre><code>interface Flyable {
  void fly();
}

class Bird implements Flyable {
  public void fly() {
    System.out.println("Flying...");
  }
}</code></pre>
  </div>

  <div class="section">
    <h2>Quick Summary</h2>
    <ul>
      <li><strong>Abstraction</strong> is a broader concept; an abstract class is one way to implement it.</li>
      <li><strong>Interface</strong> is a pure abstraction tool used for enforcing contracts between classes.</li>
    </ul>
  </div>

</div></li>
<li data-id="q14oth"><span class="faq-question green">
  🔐 OAuth 2.0 Overview
</span><div class="answer">
  <div class="section">
    <h2>What is OAuth 2.0?</h2>
    <p>OAuth 2.0 is an <strong>authorization framework</strong> that allows third-party applications to obtain limited access to a user's resources without exposing their credentials.</p>
  </div>

  <div class="section">
    <h2>Roles in OAuth 2.0</h2>
    <ul>
      <li><strong>Resource Owner:</strong> The user who owns the data.</li>
      <li><strong>Client:</strong> The application requesting access to the resource.</li>
      <li><strong>Authorization Server:</strong> Issues access tokens after authenticating the user.</li>
      <li><strong>Resource Server:</strong> Hosts the protected resources and validates the token.</li>
    </ul>
  </div>

  <div class="section">
    <h2>OAuth 2.0 Grant Types</h2>
    <ul>
      <li><strong>Authorization Code:</strong> Used for server-side applications. Secure and most commonly used.</li>
      <li><strong>Implicit:</strong> Used for public clients like single-page apps. Less secure (now discouraged).</li>
      <li><strong>Resource Owner Password Credentials:</strong> User provides credentials directly. Used in trusted apps.</li>
      <li><strong>Client Credentials:</strong> Used for machine-to-machine communication.</li>
    </ul>
  </div>

  <div class="section">
    <h2>OAuth 2.0 Flow: Authorization Code Grant</h2>
    <ol>
      <li>User is redirected to Authorization Server to log in.</li>
      <li>User grants permission to the app.</li>
      <li>Authorization Server redirects back with an <code>authorization code</code>.</li>
      <li>App exchanges the code for an <code>access token</code>.</li>
      <li>App uses the token to access protected resources.</li>
    </ol>
  </div>

  <div class="section">
    <h2>Access & Refresh Tokens</h2>
    <ul>
      <li><strong>Access Token:</strong> Used to access protected resources. Short-lived.</li>
      <li><strong>Refresh Token:</strong> Used to obtain a new access token when it expires. Long-lived.</li>
    </ul>
  </div>

  <div class="section highlight">
    <h2>Security Tips</h2>
    <ul>
      <li>Use HTTPS for all communication.</li>
      <li>Never expose client secrets in frontend apps.</li>
      <li>Use PKCE with public clients (e.g., mobile apps, SPAs).</li>
      <li>Use short-lived access tokens and refresh tokens securely.</li>
    </ul>
  </div>
  

</div></li>

<li data-id="q14"><span class="faq-question green">
Middleware?
</span><div class="answer">
Middleware in Express.js is a function that processes requests and responses during the request-response cycle. <Br />
It has access to the <code>req</code> and <code>res</code> objects and the next middleware function in the stack via the <code>next()</code> callback.<Br /><Br />
Middleware functions can perform tasks like:
<ol class="subul">
<li>Executing code</li>
<li>Modifying <code>req</code> and <code>res</code> objects</li>
<li>Ending the request-response cycle</li>
<li>Calling the next middleware</li>
</ol>
<br />
Types of middleware include:
<ol class="subul">
<li><strong>Application-level:</strong> Bound to an Express app using <code>app.use()</code> or route methods.</li>
<li><strong>Router-level:</strong> Bound to an instance of <code>express.Router()</code>.</li>
<li><strong>Error-handling:</strong> Special middleware with four arguments <code>(err, req, res, next)</code> to catch errors.</li>
<li><strong>Built-in:</strong> Provided by Express, e.g., <code>express.json()</code>, <code>express.static()</code>.</li>
<li><strong>Third-party:</strong> Such as <code>cors</code>, <code>helmet</code>, <code>morgan</code>.</li>
</ol>

Example:

<pre><code>app.use((req, res, next) =&gt; {
console.log('Request URL:', req.url);
next(); // Pass control to next middleware
});
</code></pre>

Middleware enables modular, reusable, and organized handling of HTTP requests, essential for building scalable Express.js applications.
</div></li>


<li data-id="q19"><span class="faq-question">
Circular Dependencies in react
</span><div class="answer">
A circular dependency in a React project happens when two or more modules (components, hooks, utils, contexts, etc.) depend on each other, creating a loop.
<br />

1. Restructure your code : Move shared logic to a new module both can import.<br />
2. Use dependency injection : Pass dependencies as arguments rather than importing them.<br />
<code>
  // a.js
  module.exports = (b) => {
    console.log('Using B in A');
  };   
</code><br />
3. Use dynamic import (or require) inside functions : Delay the import until the function is called.<br />
<code>
  function getB() {
    const b = require('./b');
    b();
  }  
</code>
<br />
<code>
# Install : npm install -g madge
<br />
# Run : madge --circular src/
</code>

<h5>How to Fix Circular Dependencies in React</h5>
1. Split Shared Logic into a Separate File<br />
2. Use Lazy Loading / Code Splitting<br />
Use React.lazy() to defer loading of components.<br />
<code>const Navbar = React.lazy(() => import('./Navbar'));</code>

4. Avoid Cross-Component Imports<br />
If ComponentA and ComponentB both use each other:<br />
Move shared UI into a new SubComponent<br />
Or lift shared state to the parent<br />

</div></li>



<li data-id="q19"><span class="faq-question green">
Cluster vs Worker*** cluster.fork()
</span><div class="answer">
  In Node.js, both Cluster and Worker Threads are used for parallel processing, but they serve different purposes and have distinct architectures.  
<br />
<a href="/doctor/cluster.html" target="_blank" style="color: blue; font-weight: bold;">Read More</a><br /><br />

<ol class="subul">
  <li>
    The cluster module allows you to create child processes (workers) that share the same server port. <br />
    It's used to take advantage of multi-core systems to handle concurrent requests efficiently.<br />
    It is used to utilize multiple CPU cores, improving performance for concurrent requests.<br />
    const cluster = require('cluster');<br /><br />
  </li>
  <li>
      The worker_threads module allows JavaScript code to run in parallel on multiple threads. <br />
      Useful for CPU-intensive tasks (like hashing, image processing) without blocking the main event loop.<br />
      A **worker** is an individual child process created by the cluster. <br />
      Each worker runs its own Node.js instance and handles a portion of the server load. <br />
      They can communicate with the master process via IPC (inter-process communication).<br />
      <span class="green">A **worker** is an individual child process created by the cluster. </span><br />
      Each worker runs its own Node.js instance and handles a portion of the server load. <br />
      They can communicate with the master process via IPC (inter-process communication).<br />
      const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
    </li>
</ol>
<hr />
<br />

<span class="green">
Node.js is single-threaded by default. Using the cluster module allows your app to : Handle more requests concurrently.
</span>
<ol class="subul">
  <li>Avoid a single point of failure (if one worker crashes, others keep running).</li>
  <li>Use all CPU cores on a server.</li>
  <li>All workers share the same server port.</li>
  <li>Each worker is a separate Node.js process (not thread).</li>
  <li>Workers don’t share memory – use IPC or external stores (like Redis) for shared state.</li>
</ol>
<br />


<hr />
  
  
    <div class="section">
      <br />
      <div class="title">🔄 Cluster vs Worker Comparison</div>
      <table class="table">
        <thead>
          <tr>
            <th>Aspect</th>
            <th>Cluster</th>
            <th>Worker</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Definition</td>
            <td>Main controller module to spawn child processes</td>
            <td>Individual child process spawned by the cluster</td>
          </tr>
          <tr>
            <td>Role</td>
            <td>Manages multiple workers</td>
            <td>Handles incoming requests or tasks</td>
          </tr>
          <tr>
            <td>Code Location</td>
            <td>Master process</td>
            <td>Worker process</td>
          </tr>
          <tr>
            <td>Use Case</td>
            <td>Load balancing and CPU core utilization</td>
            <td>Actual request processing</td>
          </tr>
          <tr>
            <td>Communication</td>
            <td>Interacts with workers via IPC</td>
            <td>Communicates with master via IPC</td>
          </tr>
        </tbody>
      </table>
    </div>
  
<hr />

<h2>🔍 Comparison: Manual cluster vs PM2</h2>

<table>
  <tr>
    <th>Feature</th>
    <th>Manual cluster</th>
    <th>PM2</th>
  </tr>
  <tr>
    <td>Setup</td>
    <td>Manual coding required</td>
    <td class="yes">Easy CLI-based</td>
  </tr>
  <tr>
    <td>Load balancing</td>
    <td class="yes">Handled via cluster</td>
    <td class="yes">Built-in</td>
  </tr>
  <tr>
    <td>Process Monitoring</td>
    <td class="no">Not built-in</td>
    <td class="yes">Dashboard + CLI</td>
  </tr>
  <tr>
    <td>Crash Recovery</td>
    <td class="no">Manual restart</td>
    <td class="yes">Automatic restart</td>
  </tr>
  <tr>
    <td>Logging</td>
    <td class="no">Requires setup</td>
    <td class="yes">Built-in logging</td>
  </tr>
  <tr>
    <td>Production Readiness</td>
    <td class="no">Not ideal alone</td>
    <td class="yes">✅ Highly recommended</td>
  </tr>
</table>



</div></li>



<li data-id="q19"><span class="faq-question">
Clustering? & cluster vs worker*** cluster.fork()
</span><div class="answer">

Clustering enables using multiple CPU cores by spawning worker processes that share the same server port, improving performance and load handling.
</div>
<div class="answer">
Clustering in Node.js is a technique to create multiple child processes (workers) that share the same server port, allowing you to take advantage of multi-core CPU systems. Since Node.js runs on a single thread by default, clustering helps improve performance and reliability by distributing incoming requests across several worker processes.

The core module cluster enables spawning of worker processes. Each worker runs its own event loop and instance of the Node.js runtime, enabling parallel processing of requests.
<br />
Key benefits:
<ul>
<li><strong>Improved Performance:</strong> Utilizes multiple CPU cores to handle more concurrent connections.</li>
<li><strong>Fault Tolerance:</strong> If one worker crashes, the master process can spawn a new worker, improving app resilience.</li>
<li><strong>Load Balancing:</strong> The master process balances incoming requests between workers.</li>
</ul>

Basic usage example:

<pre><code>const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
for (let i = 0; i < numCPUs; i++) {
cluster.fork();
}
cluster.on('exit', (worker) => {
console.log(`Worker ${worker.process.pid} died, spawning a new one.`);
cluster.fork();
});
} else {
http.createServer((req, res) =&gt; {
res.end('Hello from worker ' + process.pid);
}).listen(8000);
}
</code></pre>

Clustering boosts Node.js scalability but requires careful management of shared resources and state.
</div>

</li>


<li data-id="q28"><span class="faq-question green">
Performance?
</span><div class="answer">
Use clustering, caching (Redis), async operations, database indexing, code profiling, monitoring (e.g., New Relic), and limit synchronous code. Minimize memory leaks and optimize queries.
</div>
<div class="answer">
Optimizing performance in large-scale Node.js applications involves multiple strategies:
<br />
<strong>1. Use Asynchronous Code:</strong> Always prefer non-blocking async operations to avoid blocking the event loop.<br>

<strong>2. Load Balancing & Clustering:</strong> Use the cluster module or external load balancers to utilize multiple CPU cores.<br>

<strong>3. Caching:</strong> Cache frequent data using in-memory stores like Redis or Memcached to reduce database load.<br>

<strong>4. Database Optimization:</strong> Use indexing, connection pooling, and optimized queries to improve database interaction.<br>

<strong>5. Avoid Memory Leaks:</strong> Monitor heap usage, manage object lifecycles carefully, and use profiling tools like Chrome DevTools or Clinic.js.<br>

<strong>6. Use Streams:</strong> Process large data efficiently with streams to minimize memory footprint.<br>

<strong>7. Efficient Logging:</strong> Use asynchronous logging libraries and avoid excessive logging in production.<br>

<strong>8. Minimize Dependencies:</strong> Avoid bloated or unused npm packages to reduce startup time.<br>

<strong>9. Profiling & Monitoring:</strong> Continuously profile your app using tools like New Relic, Datadog, or built-in profilers.<br>

<strong>10. Use CDN & Compression:</strong> Serve static assets via CDN and compress responses with gzip or brotli.<br>

Regular code reviews, performance testing, and keeping dependencies up-to-date help maintain high performance.
</div>

</li>

<li data-id="q12"><span class="faq-question">
Difference between process.nextTick() and setImmediate()?
</span><div class="answer">
<b class="green">process.nextTick()</b> schedules a callback to execute immediately after the current operation completes, before the event loop continues. It has higher priority and runs before any I/O events or timers.
<br />
<b class="green">setImmediate()</b> schedules a callback to run on the next iteration (tick) of the event loop, after I/O events callbacks.
<br /><br />
In short,
<code>process.nextTick() : runs before any I/O tasks, can starve I/O, blocking the event loop.</code> 
<code>setImmediate() :  runs after I/O events in the event loop.</code>
 
</div>

</li>

<li data-id="q24"><span class="faq-question">
How do you secure a Node.js application?
</span><div class="answer">
Securing a Node.js application involves multiple layers of protection:<br />

<strong>1. HTTP Headers:</strong> Use <code>helmet</code> middleware to set secure HTTP headers and prevent common attacks like XSS, clickjacking, and MIME-sniffing.<br>

<strong>2. Rate Limiting:</strong> Implement request throttling using <code>express-rate-limit</code> to protect against brute-force and DDoS attacks.<br>

<strong>3. Input Validation & Sanitization:</strong> Use libraries like <code>express-validator</code> or <code>Zod</code> to validate and sanitize incoming data to avoid injection attacks.<br>

<strong>4. Authentication & Authorization:</strong> Use secure token-based auth like <code>JWT</code>. Never store sensitive info in plain text—always hash passwords with <code>bcrypt</code>.<br>

<strong>5. Use HTTPS:</strong> Encrypt communication using SSL certificates to secure data in transit.<br>

<strong>6. Avoid Eval & Unsafe Code:</strong> Never use <code>eval()</code> or <code>Function()</code> with untrusted data. These can lead to RCE (Remote Code Execution).<br>

<strong>7. Dependency Management:</strong> Use <code>npm audit</code> and tools like <code>snyk</code> to identify and fix vulnerable packages.<br>

<strong>8. Secure Cookies:</strong> Use <code>HttpOnly</code>, <code>Secure</code>, and <code>SameSite</code> flags on cookies.<br>

<strong>9. Environment Variables:</strong> Keep secrets and configs in <code>.env</code> files. Never hard-code credentials.<br>

<strong>10. Logging & Monitoring:</strong> Monitor with tools like <code>Winston</code>, <code>Morgan</code>, or services like Datadog or New Relic.

Regularly update Node.js and dependencies to stay protected.
</div></li>


<li data-id="q20"><span class="faq-question">
Explain how Buffer works in Node.js.
</span><div class="answer">
`Buffer` is a global object used to handle binary data directly. It's useful for working with streams, files, and network protocols without converting to strings.
</div></li>







<li data-id="q_ts"><span class="faq-question green">
TypeScript?
</span><div class="answer">
TypeScript is a strongly typed superset of JavaScript developed by Microsoft.<br /> 
It adds <span class="green">static typing, interfaces, enums, and advanced tooling features to JavaScript, 
helping developers catch errors at compile time instead of runtime.</span> 
TypeScript code compiles down to plain JavaScript, making it compatible with any environment that runs JS. It improves code quality, readability, and maintainability, especially for large-scale applications. TypeScript integrates well with modern frameworks like Angular, React, and Node.js, and offers excellent support in popular editors like VS Code with features like autocompletion and refactoring.
</div></li>

<li data-id="q_gql"><span class="faq-question">
GraphQL?
</span><div class="answer">
GraphQL offers several advantages over traditional REST APIs:
<ul>
<li><strong>Flexible Queries:</strong> Clients can request exactly the data they need, reducing over-fetching and under-fetching.</li>
<li><strong>Single Endpoint:</strong> All data queries and mutations happen through one endpoint, simplifying API management.</li>
<li><strong>Strongly Typed Schema:</strong> The schema defines the types and relationships, enabling better validation and tooling.</li>
<li><strong>Efficient Data Loading:</strong> Supports batching and caching to minimize redundant data fetching.</li>
<li><strong>Improved Developer Experience:</strong> Introspection and auto-generated documentation make development faster and easier.</li>
<li><strong>Real-time Data:</strong> Supports subscriptions for live updates.</li>
</ul>
These features make GraphQL ideal for complex, evolving APIs and frontend-driven development.
</div></li>

<li data-id="q_react_state"><span class="faq-question">
State in React?
</span><div class="answer">
State in React is an object that holds dynamic data for a component. It determines how the component behaves and renders. When the state changes, React automatically re-renders the component to reflect the new data. State is managed within the component (using <code>useState</code> in functional components) and should be updated using the provided setter function to ensure proper reactivity.

</div></li>

<li data-id="q_react_vs_next"><span class="faq-question">
Difference between React.js and Next.js?
</span><div class="answer">
<strong>React.js</strong> is a JavaScript library for building user interfaces, mainly focused on the frontend. It offers a component-based approach and handles client-side rendering but doesn’t include built-in routing or server-side rendering.

<strong>Next.js</strong> is a React framework that extends React by adding powerful features like:
<ul>
<li>File-based routing</li>
<li>Server-side rendering (SSR)</li>
<li>Static site generation (SSG)</li>
<li>API routes</li>
<li>SEO optimization</li>
</ul>
While React provides the foundation for UI, Next.js offers a complete solution for building full-stack applications with better performance and scalability.
</div></li>

<li data-id="q_react_memory_virtualization"><span class="faq-question">
memory cleanup and virtualization in React.js?
</span><div class="answer">
<strong>Memory Cleanup:</strong> In React, memory cleanup is often done using the <code>useEffect</code> hook’s cleanup function. It prevents memory leaks by cleaning up subscriptions, timers, or event listeners when a component unmounts or before re-running the effect.

Example:
<pre><code>
useEffect(() => {
const timer = setInterval(() => console.log('Tick'), 1000);
return () => clearInterval(timer); // Cleanup
}, []);
</code></pre>

<strong>Virtualization:</strong> Virtualization improves performance by rendering only the visible portion of large lists instead of the entire list. Libraries like <code>react-window</code> or <code>react-virtualized</code> help with this.

Example with <code>react-window</code>:
<pre><code>
import { FixedSizeList as List } from 'react-window';

&lt;List height={400} itemCount={1000} itemSize={35} width={300}&gt;
{({ index, style }) =&gt; &lt;div style={style}&gt;Item {index}&lt;/div&gt;}
&lt;/List&gt;
</code></pre>

This boosts performance and reduces memory usage in large UIs.
</div></li>
<li data-id="q_design_patterns"><span class="faq-question">
What are design patterns in Node.js?
</span><div class="answer">
Design patterns are reusable solutions to common software design problems. In Node.js, popular patterns include:<br />

<strong>1. Singleton:</strong> Ensures a class has only one instance (e.g., database connection).<br>
<strong>2. Factory:</strong> Creates objects without exposing the instantiation logic.<br>
<strong>3. Observer:</strong> Implements pub-sub mechanisms (e.g., <code>EventEmitter</code>).<br>
<strong>4. Middleware:</strong> Common in Express apps for request handling.<br>
<strong>5. Module Pattern:</strong> Uses closures to encapsulate logic.

Using design patterns improves code organization, reusability, and maintainability in scalable Node.js applications.
</div></li>
<li data-id="q_design_patterns_more"><span class="faq-question">
Explain Singleton, Factory, Observer, Middleware, and Module patterns in Node.js
</span><div class="answer">
<strong>Singleton:</strong> Restricts a class to one instance. Useful for shared resources like DB connections. Ensures consistent state across the app.<br><br>

<strong>Factory:</strong> Creates objects without specifying exact classes. It abstracts object creation, allowing flexible and interchangeable products.<br><br>

<strong>Observer:</strong> Implements event-driven communication where objects subscribe to events and get notified on changes. Node’s <code>EventEmitter</code> is a classic example.<br><br>

<strong>Middleware:</strong> Functions that intercept requests in a chain to process or modify them. Common in Express.js for logging, authentication, or error handling.<br><br>

<strong>Module Pattern:</strong> Uses closures to encapsulate private variables and expose a public API. Helps in organizing code into reusable, maintainable parts.<br><br>

These patterns help write modular, scalable, and maintainable Node.js applications.
</div></li>
<li data-id="q_solid"><span class="faq-question">
SOLID in software development?
</span><div class="answer">
SOLID is a set of five design principles aimed at making software designs more understandable, flexible, and maintainable:<br><br>

<strong>S</strong> - Single Responsibility Principle: A class should have only one reason to change.<br>
<strong>O</strong> - Open/Closed Principle: Software entities should be open for extension but closed for modification.<br>
<strong>L</strong> - Liskov Substitution Principle: Subclasses should be replaceable by their base classes without affecting correctness.<br>
<strong>I</strong> - Interface Segregation Principle: Clients should not be forced to depend on interfaces they don’t use.<br>
<strong>D</strong> - Dependency Inversion Principle: High-level modules should not depend on low-level modules but on abstractions.<br><br>

Applying SOLID improves code quality and eases maintenance.
</div></li>

<li data-id="q_datatypes"><span class="faq-question">
Data types in JavaScript?
</span><div class="answer">
JavaScript has two main types of data types:<br><br>

<strong>1. Primitive Types:</strong><br>
- <code>String</code>: e.g., "hello"<br>
- <code>Number</code>: e.g., 123, 3.14<br>
- <code>Boolean</code>: true or false<br>
- <code>Undefined</code>: a variable declared but not assigned<br>
- <code>Null</code>: intentional absence of any value<br>
- <code>Symbol</code>: unique and immutable value<br>
- <code>BigInt</code>: for large integers beyond Number limits<br><br>

<strong>2. Non-Primitive (Reference) Types:</strong><br>
- <code>Object</code>: includes arrays, functions, dates, etc.<br><br>

Primitive types are compared by value, while objects are compared by reference.
</div></li>








<li data-id="q_currying"><span class="faq-question">
Currying?
</span><div class="answer">
Currying is a functional programming technique where a function is transformed into a sequence of functions, each taking a single argument. Instead of taking all arguments at once, a curried function takes them one by one.

It improves code reusability and function composition.

Example:
<pre><code>
// Normal function
function add(a, b) {
return a + b;
}

// Curried version
function curriedAdd(a) {
return function(b) {
return a + b;
};
}

console.log(curriedAdd(2)(3)); // 5
</code></pre>
Currying is useful for creating customizable and reusable function pipelines.
</div></li>

<li data-id="q_oauth2"><span class="faq-question green">
OAuth 2.0?
</span><div class="answer">
OAuth 2.0 is an authorization framework that enables third-party applications to obtain limited access to user resources on a server without exposing user credentials.

It works by issuing access tokens after user consent, which the application uses to access protected resources.
<br />
Key roles:<br />
- <strong class="green">Resource Owner:</strong> User granting access<br />
- <strong>Client:</strong> Application requesting access<br />
- <strong>Authorization Server:</strong> Issues tokens<br />
- <strong>Resource Server:</strong> Hosts protected resources<br />

Common grant types:<br />
- Authorization Code<br />
- Implicit<br />
- Resource Owner Password Credentials<br />
- Client Credentials<br />

OAuth 2.0 improves security by decoupling authentication and authorization, widely used in APIs and social logins.
</div></li>


<li data-id="q_token_vs_session"><span class="faq-question">
the difference between Token and Session?
</span><div class="answer">
<strong>Session:</strong><br>
- Server stores user state and session ID.<br>
- Client holds session ID in cookies.<br>
- Requires server-side memory or storage.<br>
- Easier to invalidate on logout.<br>

<strong>Token (e.g., JWT):</strong><br>
- Self-contained, stateless authentication.<br>
- Token holds user info, signed by server.<br>
- Stored client-side (localStorage/cookies).<br>
- Scales better, no server memory needed.<br>

<strong>Summary:</strong><br>
Sessions are server-managed; tokens are client-managed. Tokens are popular for APIs and stateless apps; sessions suit traditional web apps.
</div></li>

<li data-id="q_mysql_acid"><span class="faq-question">
ACID in MySQL?
</span><div class="answer">
ACID stands for Atomicity, Consistency, Isolation, and Durability — key properties that ensure reliable database transactions.
<br />
- <strong>Atomicity:</strong> Transactions are all-or-nothing; either fully completed or fully rolled back.<br>
- <strong>Consistency:</strong> Transactions bring the database from one valid state to another, maintaining data integrity.<br>
- <strong>Isolation:</strong> Concurrent transactions don’t interfere; intermediate states are hidden.<br>
- <strong>Durability:</strong> Once committed, changes persist even after crashes.

MySQL’s InnoDB engine supports ACID to guarantee safe and reliable transactions.
</div></li>

<li data-id="q_aws_api_gateway"><span class="faq-question">
AWS API Gateway?
</span><div class="answer">
AWS API Gateway is a fully managed service that enables developers to create, publish, maintain, monitor, and secure APIs at any scale.

It acts as a front door for applications to access backend services like AWS Lambda, EC2, or external endpoints.

Key features:<br>
- Supports RESTful and WebSocket APIs.<br>
- Handles request routing, throttling, authorization, and monitoring.<br>
- Integrates with AWS services for security (Cognito, IAM).<br>
- Enables caching to improve performance.<br>

API Gateway simplifies building scalable, secure, and reliable APIs with minimal infrastructure management.
</div></li>


<li data-id="q_virtual_dom"><span class="faq-question">
Virtual DOM in ReactJS?
</span><div class="answer">
The <strong>Virtual DOM</strong> is a lightweight, in-memory representation of the real DOM used by React.<br />

When the state or props of a component change, React creates a new Virtual DOM tree and compares it with the previous one (called "diffing").
<br />
Only the differences (minimal changes) are then applied to the actual browser DOM, improving performance by reducing costly DOM manipulations.
<br />
This process allows React to update UI efficiently and smoothly without reloading the entire page.
</div></li>


<li data-id="q_useeffect"><span class="faq-question">
useEffect in ReactJS?
</span><div class="answer">
<code>useEffect</code> is a React Hook that lets you perform side effects in functional components, such as data fetching, subscriptions, or manually changing the DOM.

It runs after the component renders and can be configured to run:
- After every render (no dependencies),
- Only once on mount (empty dependency array),
- Or when specific values change (dependencies array).

Example:
<pre><code>
useEffect(() => {
// side effect logic
}, [dependency]);
</code></pre>

It replaces lifecycle methods like <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code>.
</div></li>

<li data-id="q_context_api"><span class="faq-question">
Context API in React?
</span><div class="answer">
The <strong>Context API</strong> in React provides a way to pass data through the component tree without prop drilling (passing props manually at every level).

It allows sharing global data like themes, user info, or settings.

Usage involves three parts:
- <code>React.createContext()</code> to create context.
- <code>Context.Provider</code> to provide data.
- <code>Context.Consumer</code> or <code>useContext()</code> hook to consume data.

Example:
<pre><code>
const ThemeContext = React.createContext('light');

function App() {
return (
&lt;ThemeContext.Provider value="dark"&gt;
&lt;Toolbar /&gt;
&lt;/ThemeContext.Provider&gt;
);
}
</code></pre>

It simplifies state management for global data.
</div></li>

<li data-id="q_event_bubbling"><span class="faq-question">
What is Event Bubbling in ReactJS?
</span><div class="answer">
  <strong>Event bubbling</strong> in ReactJS is a mechanism where an event triggered on a child element propagates (or "bubbles") up through its parent elements in the DOM tree.
  
  For example, clicking a button inside a <code>&lt;div&gt;</code> will first fire the button’s <code>onClick</code> handler, then the <code>&lt;div&gt;</code>'s if one is defined.
  
  Example:
  <pre><code>
  &lt;div onClick={() =&gt; console.log('Div clicked')}&gt;
    &lt;button onClick={() =&gt; console.log('Button clicked')}&gt;Click Me&lt;/button&gt;
  &lt;/div&gt;
  </code></pre>
  
  Clicking the button will log:<br>
  <code>Button clicked</code><br>
  <code>Div clicked</code>
  
  You can stop bubbling with <code>event.stopPropagation()</code>.
  </div></li>
  


    











































  <li data-id="q_call_api_without_useeffect"><span class="faq-question green">
    MySQL : INNER, LEFT & RIGHT-OUTER, FULL OUTER JOIN, CROSS JOIN, SELF JOIN
  </span><div class="answer">
  <ol class="subul">
    <li><b>FULL OUTER JOIN :</b>(MySQL does not support this natively)</li>
    <li><b>INNER JOIN :</b> Returns only matching rows from both tables.</li>
    <li><b>CROSS JOIN :</b> Returns the Cartesian product (all combinations) of the two tables.</li>
    <li><b>SELF JOIN :</b> A table joined to itself using aliases.</li>
    <li>
      <code>
        SELECT * FROM employees e <span class="green">LEFT JOIN</span> departments d ON e.department_id = d.id <br />
        <span class="green">UNION</span><br />
        SELECT * FROM employees e RIGHT JOIN departments d ON e.department_id = d.id; <br /><hr />
        SELECT * FROM employees <span class="green">CROSS JOIN</span> departments;<br /><hr />

        SELECT a.name AS employee, b.name AS manager FROM employees a JOIN employees b ON a.manager_id = b.id;
        
      </code>
    </li>
  </ol>
  </div></li>


  <li data-id="q_call_api_without_useeffect"><span class="faq-question green">
    Advantages of Sequelize
  </span><div class="answer">




    
  
    <h2>✅ 1. Supports Multiple SQL Databases</h2>
    <p>Sequelize supports:</p>
    <ul>
      <li>PostgreSQL</li>
      <li>MySQL</li>
      <li>MariaDB</li>
      <li>SQLite</li>
      <li>MSSQL</li>
    </ul>
  
    <h2>✅ 2. Promise-based</h2>
    <p>Built on Promises, making it easy to use with async/await for clean asynchronous flow.</p>
  
    <h2>✅ 3. Models & Associations</h2>
    <p>Define relationships using built-in methods:</p>
    <pre><code>User.hasMany(Post);
  Post.belongsTo(User);</code></pre>
  
    <h2>✅ 4. Migrations & Seeders</h2>
    <p>Includes CLI tools to manage database schema versions and initial data.</p>
  
    <h2>✅ 5. ORM & Raw SQL</h2>
    <p>Allows flexible querying with both ORM methods and raw SQL:</p>
    <pre><code>const users = await sequelize.query("SELECT * FROM Users", { type: QueryTypes.SELECT });</code></pre>
  
    <h2>✅ 6. Hooks/Lifecycle Callbacks</h2>
    <p>Execute logic before/after events like save, update, delete:</p>
    <pre><code>User.beforeCreate(user => {
    user.createdAt = new Date();
  });</code></pre>
  
    <h2>✅ 7. Eager & Lazy Loading</h2>
    <p>Supports both eager loading via <code>include</code> and lazy loading via functions.</p>
  
    <h2>✅ 8. Transaction Support</h2>
    <p>Robust support for transactions:</p>
    <pre><code>await sequelize.transaction(async (t) => {
    await User.create({ name: 'John' }, { transaction: t });
  });</code></pre>
  
    <h2>✅ 9. Validation & Constraints</h2>
    <p>Define validations, constraints, and default values at the model level.</p>
  
    <h2>✅ 10. Community & Ecosystem</h2>
    <p>Widely used in production with great community and support.</p>

  
  </div></li>






  
  <li data-id="q_call_api_without_useeffect"><span class="faq-question green">
  TypeORM
</span><div class="answer">

  <ul>
    <li>Object-Oriented design using decorators</li>
    <li>Supports Active Record & Data Mapper</li>
    <li>Works with various databases (MySQL, PostgreSQL, etc.)</li>
    <li>Built-in migration support</li>
    <li>Eager and lazy relation loading</li>
    <li>Repository and QueryBuilder APIs</li>
    <li>Easy configuration using decorators</li>
    <li>Great integration with NestJS</li>
  </ul>




  
    <h2>✅ 1. TypeScript Support</h2>
    <p>Fully written in and optimized for TypeScript. Enables <strong>type safety</strong>, <strong>intellisense</strong>, and <strong>compile-time checks</strong>.</p>
  
    <h2>✅ 2. Decorators-Based Syntax</h2>
    <p>Uses <strong>class decorators</strong> for defining entities, columns, and relationships—clean and declarative.</p>
    <pre><code>@Entity()
  export class User {
    @PrimaryGeneratedColumn()
    id: number;
  
    @Column()
    name: string;
  }</code></pre>
  
    <h2>✅ 3. Supports Multiple Databases</h2>
    <p>Works with:</p>
    <ul>
      <li>MySQL</li>
      <li>PostgreSQL</li>
      <li>SQLite</li>
      <li>MariaDB</li>
      <li>MSSQL</li>
      <li>Oracle</li>
      <li>MongoDB (limited)</li>
    </ul>
  
    <h2>✅ 4. Built-In Migrations</h2>
    <p>Supports schema migrations for database version control:</p>
    <pre><code>typeorm migration:create -n AddUserTable
  typeorm migration:run</code></pre>
  
    <h2>✅ 5. Repository & Data Mapper Patterns</h2>
    <p>Supports both <strong>Active Record</strong> and <strong>Data Mapper</strong> patterns.</p>
  
    <h2>✅ 6. Relationship Management</h2>
    <p>Easy to define and manage entity relationships:</p>
    <pre><code>@OneToMany(() => Post, post => post.user)
  posts: Post[];</code></pre>
  
    <h2>✅ 7. Lazy & Eager Loading</h2>
    <p>Supports both <strong>lazy</strong> (via Promises) and <strong>eager</strong> loading of relations.</p>
  
    <h2>✅ 8. Query Builder</h2>
    <p>Flexible query builder for complex queries:</p>
    <pre><code>const users = await dataSource
    .getRepository(User)
    .createQueryBuilder("user")
    .where("user.age > :age", { age: 18 })
    .getMany();</code></pre>
  
    <h2>✅ 9. Integration with NestJS</h2>
    <p>Works seamlessly with NestJS via the <code>@nestjs/typeorm</code> package.</p>
  
    <h2>✅ 10. Community & Ecosystem</h2>
    <p>Well-maintained and widely adopted in production apps.</p>

  


</div></li>



<li data-id="q3"><span class="faq-question">
Lazy vs Eager Loading
</span><div class="answer">

  <h2>✅ Lazy Loading</h2>
  <p>Lazy loading delays the loading of data or resources until they are actually needed.</p>

  <h3>🔍 Characteristics:</h3>
  <ul>
    <li>Data is fetched only <strong>when accessed</strong>.</li>
    <li>Reduces initial load time.</li>
    <li>Saves memory and network if the data is never used.</li>
    <li>Might introduce <strong>additional queries or requests</strong> during runtime.</li>
  </ul>

  <h3>💡 Examples:</h3>
  <div class="code-title">Backend (ORM):</div>
  <pre><code>@OneToMany(() =&gt; Post, post =&gt; post.user, { lazy: true })
posts: Promise&lt;Post[]&gt;;</code></pre>

  <div class="code-title">Frontend (React):</div>
  <pre><code>const LazyComponent = React.lazy(() =&gt; import('./MyComponent'));</code></pre>

  <h2>✅ Eager Loading</h2>
  <p>Eager loading loads related data immediately when the initial query or request is made.</p>

  <h3>🔍 Characteristics:</h3>
  <ul>
    <li>Data is <strong>pre-fetched</strong> along with the primary data.</li>
    <li>Useful when you know the related data will be needed.</li>
    <li>Reduces the number of queries at runtime (prevents N+1 problem).</li>
    <li>Increases initial load time.</li>
  </ul>

  <h3>💡 Examples:</h3>
  <div class="code-title">Backend (ORM):</div>
  <pre><code>@OneToMany(() =&gt; Post, post =&gt; post.user, { eager: true })
posts: Post[];</code></pre>

  <div class="code-title">Frontend (React/Angular):</div>
  <pre><code>// Importing all modules/components at once during the initial load</code></pre>

  <h2>🆚 Lazy vs Eager Loading – Quick Comparison</h2>
  <table>
    <thead>
      <tr>
        <th>Feature</th>
        <th>Lazy Loading</th>
        <th>Eager Loading</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Timing</td>
        <td>On demand</td>
        <td>At initial load</td>
      </tr>
      <tr>
        <td>Performance Impact</td>
        <td>Lower initial cost, may slow runtime</td>
        <td>Higher initial cost, faster runtime</td>
      </tr>
      <tr>
        <td>Use Case</td>
        <td>Optional or rarely used data</td>
        <td>Essential or frequently accessed data</td>
      </tr>
      <tr>
        <td>Query Behavior</td>
        <td>Multiple small queries</td>
        <td>Single large query</td>
      </tr>
    </tbody>
  </table>

  <h2>🧠 When to Use What?</h2>
  <ul>
    <li><strong>Lazy Loading</strong>: When the related data is large, rarely used, or optional.</li>
    <li><strong>Eager Loading</strong>: When you always need the related data and want to avoid N+1 queries.</li>
  </ul>

</div></li>

<li data-id="q3"><span class="faq-question green">
  TypeORM vs Sequelize ***
  </span><div class="answer">


    
      <h1>TypeORM vs Sequelize</h1>
    
      <h2>🔶 Overview</h2>
      <table>
        <tr>
          <th>Feature</th>
          <th>TypeORM</th>
          <th>Sequelize</th>
        </tr>
        <tr>
          <td>Language</td>
          <td>TypeScript-first ORM</td>
          <td>JavaScript-first (TypeScript support)</td>
        </tr>
        <tr>
          <td>API Style</td>
          <td>Decorator-based OOP (like Java/C#)</td>
          <td>Promise-based functional API</td>
        </tr>
        <tr>
          <td>Supported DBs</td>
          <td>MySQL, PostgreSQL, SQLite, MSSQL, etc.</td>
          <td>MySQL, PostgreSQL, SQLite, MSSQL, etc.</td>
        </tr>
        <tr>
          <td>Learning Curve</td>
          <td>Steeper for beginners</td>
          <td>Easier, beginner-friendly</td>
        </tr>
        <tr>
          <td>Community</td>
          <td>Growing in TS community</td>
          <td>Mature and stable</td>
        </tr>
      </table>
    
      <h2>🔶 Coding Style</h2>
    
      <h3>✅ TypeORM</h3>
      <pre><code>@Entity()
    export class User {
      @PrimaryGeneratedColumn()
      id: number;
    
      @Column()
      name: string;
    
      @OneToMany(() => Post, post => post.user)
      posts: Post[];
    }</code></pre>
    
      <h3>✅ Sequelize</h3>
      <pre><code>const User = sequelize.define('User', {
      name: {
        type: Sequelize.STRING
      }
    });
    
    User.hasMany(Post);</code></pre>
    
      <h2>🔶 Feature Comparison</h2>
      <table>
        <tr>
          <th>Feature</th>
          <th>TypeORM</th>
          <th>Sequelize</th>
        </tr>
        <tr>
          <td>TypeScript Support</td>
          <td>Native, first-class support</td>
          <td>Good, but less idiomatic</td>
        </tr>
        <tr>
          <td>Decorators</td>
          <td>Yes</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Migrations</td>
          <td>Supported (CLI-based)</td>
          <td>Supported (CLI-based)</td>
        </tr>
        <tr>
          <td>Query Builder</td>
          <td>Yes (powerful)</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Active Record Support</td>
          <td>✅ Yes</td>
          <td>✅ Yes</td>
        </tr>
        <tr>
          <td>Data Mapper Support</td>
          <td>✅ Yes</td>
          <td>✅ Yes</td>
        </tr>
        <tr>
          <td>Hooks / Lifecycle Events</td>
          <td>Supported</td>
          <td>Supported</td>
        </tr>
        <tr>
          <td>Custom Repositories</td>
          <td>Supported</td>
          <td>Less structured</td>
        </tr>
        <tr>
          <td>Raw Queries</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Lazy Loading Support</td>
          <td>✅ Yes (via proxies)</td>
          <td>❌ No</td>
        </tr>
        <tr>
          <td>Ecosystem Plugins</td>
          <td>Smaller</td>
          <td>Larger</td>
        </tr>
        <tr>
          <td>Performance</td>
          <td>Comparable, context-specific</td>
          <td>Comparable, context-specific</td>
        </tr>
      </table>
    
      <h2>🔶 Pros & Cons</h2>
    
      <h3>✅ TypeORM</h3>
      <ul>
        <li>Built for TypeScript from the ground up.</li>
        <li>Cleaner, OOP-style with decorators.</li>
        <li>Easy to manage entities and relations.</li>
        <li>Supports both Active Record & Data Mapper.</li>
        <li><strong>Cons:</strong> Can be buggy, poor error messages, slower dev pace.</li>
      </ul>
    
      <h3>✅ Sequelize</h3>
      <ul>
        <li>Mature, stable, and widely used.</li>
        <li>Rich feature set with powerful associations and hooks.</li>
        <li>Easier to get started for beginners.</li>
        <li><strong>Cons:</strong> Less seamless TS support, no decorators, more verbose.</li>
      </ul>
    
      <h2>🔶 When to Use What?</h2>
      <table>
        <tr>
          <th>Use Case</th>
          <th>Recommendation</th>
        </tr>
        <tr>
          <td>Full TypeScript project</td>
          <td>✅ TypeORM</td>
        </tr>
        <tr>
          <td>Simple JavaScript project</td>
          <td>✅ Sequelize</td>
        </tr>
        <tr>
          <td>OOP/decorator-based architecture</td>
          <td>✅ TypeORM</td>
        </tr>
        <tr>
          <td>Large team with JavaScript experience</td>
          <td>✅ Sequelize</td>
        </tr>
        <tr>
          <td>Lazy loading required</td>
          <td>✅ TypeORM</td>
        </tr>
        <tr>
          <td>Rapid prototyping / MVP</td>
          <td>✅ Sequelize</td>
        </tr>
      </table>
    
      <h2>🔚 Final Thoughts</h2>
      <p>
        Use <strong>TypeORM</strong> if you're building a scalable TypeScript-based app and want an OOP approach with decorators.<br>
        Use <strong>Sequelize</strong> if you want fast setup, simplicity, and a mature JS ORM with wide community support.
      </p>
    

    
  </div></li>

<li data-id="q3"><span class="faq-question">
DB Indexing   
</span><div class="answer">

  

    <p><strong>Database indexing</strong> is a data structure technique used to quickly locate and access data in a database. It improves <strong>read</strong> performance (especially <code>SELECT</code> queries) by reducing the number of rows scanned.</p>
  
    <h2>🧠 Analogy</h2>
    <p>Think of an index in a book. Instead of reading every page to find a topic, you look it up in the index → it tells you the page number → you go directly there.</p>
  
    <h2>⚙️ How It Works</h2>
    <ul>
      <li>A <strong>B-Tree</strong> or <strong>Hash Table</strong> structure is used.</li>
      <li>Indexes are built on one or more <strong>columns</strong>.</li>
      <li>Query engine checks the index first instead of scanning the whole table.</li>
    </ul>
  
    <h2>🔍 Types of Indexes</h2>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Primary Index</strong></td>
          <td>Automatically created on the primary key.</td>
        </tr>
        <tr>
          <td><strong>Unique Index</strong></td>
          <td>Ensures all values in the column(s) are unique.</td>
        </tr>
        <tr>
          <td><strong>Composite Index</strong></td>
          <td>An index on multiple columns (e.g., <code>(first_name, last_name)</code>).</td>
        </tr>
        <tr>
          <td><strong>Full-Text Index</strong></td>
          <td>Used for text searching (e.g., <code>LIKE</code> or <code>MATCH AGAINST</code>).</td>
        </tr>
        <tr>
          <td><strong>Spatial Index</strong></td>
          <td>For geometric or GIS data.</td>
        </tr>
        <tr>
          <td><strong>Partial Index</strong></td>
          <td>Indexes only rows that meet a condition (<code>WHERE</code> clause).</td>
        </tr>
        <tr>
          <td><strong>Covering Index</strong></td>
          <td>All columns required by a query are in the index → no table access needed.</td>
        </tr>
      </tbody>
    </table>
  
    <h2>💡 Best Practices</h2>
    <ul>
      <li>Index columns used in <code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code>, and <code>GROUP BY</code>.</li>
      <li>Avoid indexing columns that are frequently updated or contain many duplicate values.</li>
      <li>Don’t over-index — it slows down <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations.</li>
      <li>Use <strong>composite indexes</strong> for multi-column filters.</li>
    </ul>
  
    <h2>🧪 Example in MySQL/PostgreSQL</h2>
    <pre><code>-- Create a simple index
  CREATE INDEX idx_users_email ON users(email);
  
  -- Composite index
  CREATE INDEX idx_users_name ON users(first_name, last_name);
  
  -- Drop an index
  DROP INDEX idx_users_email;
  </code></pre>
  
    <h2>🧠 Query Plan (Advanced)</h2>
    <p>Use <code>EXPLAIN</code> (MySQL) or <code>EXPLAIN ANALYZE</code> (PostgreSQL) to see if your query uses an index:</p>
    <pre><code>EXPLAIN SELECT * FROM users WHERE email = 'user@example.com';</code></pre>

  
</div></li>


<li data-id="redis-diff"><span class="faq-question green">
  📊 Redis vs RabbitMQ vs Kafka vs AWS SNS
  </span><div class="answer">
    
    
    <table>
      <tr>
        <th>Feature</th>
        <th>Redis</th>
        <th>RabbitMQ</th>
        <th>Apache Kafka</th>
        <th>AWS SNS</th>
      </tr>
    
      <tr>
        <td>Type</td>
        <td>In-memory data store & lightweight message broker</td>
        <td>Traditional message broker</td>
        <td>Distributed event streaming platform</td>
        <td>Managed pub/sub messaging service</td>
      </tr>
    
      <tr>
        <td>Use Case</td>
        <td>Caching, queues, lightweight pub/sub</td>
        <td>Reliable message queuing (task/job queues)</td>
        <td>High-throughput log/event streaming</td>
        <td>Fan-out messages to multiple AWS services or HTTP endpoints</td>
      </tr>
    
      <tr>
        <td>Persistence</td>
        <td>Optional (RDB, AOF)</td>
        <td>Yes (durable queues)</td>
        <td>Yes (retains logs)</td>
        <td>No built-in persistence (fire-and-forget)</td>
      </tr>
    
      <tr>
        <td>Ordering Guarantees</td>
        <td>Per-list, not global</td>
        <td>Per-queue</td>
        <td>Per-partition</td>
        <td>No strict guarantees</td>
      </tr>
    
      <tr>
        <td>Message Retention</td>
        <td>Until consumed or expired</td>
        <td>Until consumed or TTL expires</td>
        <td>Configurable retention (days/weeks)</td>
        <td>Delivers and discards</td>
      </tr>
    
      <tr>
        <td>Throughput</td>
        <td>High (in-memory)</td>
        <td>Medium</td>
        <td>Very High (sequential disk I/O, batching)</td>
        <td>Medium (event broadcast scale)</td>
      </tr>
    
      <tr>
        <td>Scalability</td>
        <td>Vertical (or Redis Cluster)</td>
        <td>Limited (clusters supported with plugins)</td>
        <td>Horizontal (Kafka Cluster, partitions)</td>
        <td>Fully managed and scalable</td>
      </tr>
    
      <tr>
        <td>Delivery Semantics</td>
        <td>At most once (by default)</td>
        <td>At least once (manual ack)</td>
        <td>At most once / At least once / Exactly once</td>
        <td>At most once (no retries by default)</td>
      </tr>
    
      <tr>
        <td>Protocol Support</td>
        <td>Custom RESP, Pub/Sub, Streams</td>
        <td>AMQP, MQTT, STOMP</td>
        <td>Kafka Protocol</td>
        <td>HTTPS, AWS SDK</td>
      </tr>
    
      <tr>
        <td>Built-in Retry</td>
        <td>No</td>
        <td>Yes</td>
        <td>Consumer responsibility</td>
        <td>No (use with Lambda, SQS for retries)</td>
      </tr>
    
      <tr>
        <td>Latency</td>
        <td>Low</td>
        <td>Low to Medium</td>
        <td>Low (with batching)</td>
        <td>Medium</td>
      </tr>
    
      <tr>
        <td>High Availability</td>
        <td>Redis Sentinel / Cluster</td>
        <td>Mirrored/Quorum Queues</td>
        <td>Built-in replication</td>
        <td>Managed by AWS</td>
      </tr>
    
      <tr>
        <td>Best For</td>
        <td>Simple queues, caching, pub/sub</td>
        <td>Decoupling microservices</td>
        <td>Event streaming, log processing</td>
        <td>Triggering distributed systems (fan-out)</td>
      </tr>
    
    </table>
    
    
</div></li>

<li data-id="redis-q"><span class="faq-question green">
  🐇 Redis
  </span><div class="answer">

    
      <h1>🚀 Redis Interview Questions</h1>
    
      <div class="question">1. What is Redis?</div>
      <div class="answer">Redis (Remote Dictionary Server) is an open-source, in-memory data structure store used as a database, cache, and message broker.</div>
    
      <div class="question">2. What are the main data types in Redis?</div>
      <div class="answer">
        - String<br>
        - List<br>
        - Set<br>
        - Sorted Set<br>
        - Hash<br>
        - Bitmap, HyperLogLog, Stream, and Geospatial Indexes
      </div>
    
      <div class="question">3. What is the default port for Redis?</div>
      <div class="answer">6379</div>
    
      <div class="question">4. Is Redis single-threaded or multi-threaded?</div>
      <div class="answer">Redis is single-threaded for commands, but supports multi-threaded I/O for performance since Redis 6.0.</div>
    
      <div class="question">5. What is the difference between Redis and Memcached?</div>
      <div class="answer">
        Redis supports complex data structures, persistence, and replication.<br>
        Memcached is limited to simple key-value pairs with no persistence or advanced structures.
      </div>
    
      <div class="question">6. What is a Redis keyspace?</div>
      <div class="answer">A Redis keyspace refers to all keys in a Redis database. Redis supports multiple databases (default is DB 0).</div>
    
      <div class="question">7. What is TTL in Redis?</div>
      <div class="answer">TTL (Time to Live) is the time (in seconds) a key will exist before being automatically deleted.</div>
    
      <div class="question">8. How do you persist data in Redis?</div>
      <div class="answer">
        Redis supports two types of persistence:<br>
        - RDB (point-in-time snapshot)<br>
        - AOF (Append-Only File that logs each write operation)
      </div>
    
      <div class="question">9. What is Redis replication?</div>
      <div class="answer">Redis supports master-slave replication to create read-only replicas for scalability and redundancy.</div>
    
      <div class="question">10. What is Redis Sentinel?</div>
      <div class="answer">Sentinel provides high availability by monitoring Redis instances, promoting a slave to master on failure.</div>
    
      <div class="question">11. What is Redis Cluster?</div>
      <div class="answer">Redis Cluster allows horizontal scaling by partitioning data across multiple nodes using hash slots.</div>
    
      <div class="question">12. What command is used to check TTL of a key?</div>
      <div class="answer"><code>TTL key</code></div>
    
      <div class="question">13. How can you delete all keys in Redis?</div>
      <div class="answer"><code>FLUSHALL</code> (for all DBs) or <code>FLUSHDB</code> (for current DB)</div>
    
      <div class="question">14. How do you make Redis threads safe?</div>
      <div class="answer">Redis is single-threaded and thread-safe by default for client connections. Use connection pooling in multi-threaded clients.</div>
    
      <div class="question">15. What is pipelining in Redis?</div>
      <div class="answer">Pipelining allows sending multiple commands without waiting for their replies, improving throughput.</div>
    
      <div class="question">16. What are pub/sub channels in Redis?</div>
      <div class="answer">Redis supports publish/subscribe messaging where messages sent to a channel are received by all subscribers.</div>
    
      <div class="question">17. What is the difference between SCAN and KEYS?</div>
      <div class="answer">
        - KEYS returns all matching keys and can block the server.<br>
        - SCAN is non-blocking and suitable for production usage.
      </div>
    
      <div class="question">18. What is the maximum size of a Redis key or value?</div>
      <div class="answer">The maximum key size is 512 MB. Same for values depending on data type and memory limits.</div>
    
      <div class="question">19. Can Redis be used for message queuing?</div>
      <div class="answer">Yes, using lists (RPUSH + LPOP/BRPOP), streams, or pub/sub for real-time messaging patterns.</div>
    
      <div class="question">20. How do you monitor Redis?</div>
      <div class="answer">Use commands like <code>INFO</code>, <code>MONITOR</code>, or external tools like RedisInsight, Prometheus, or Grafana.</div>
    
    </div></li>



<li data-id="rabbitmq"><span class="faq-question green">
  🐇 RabbitMQ
  </span><div class="answer">


  <div class="question">1. What is RabbitMQ?</div>
  <div class="answer">RabbitMQ is an open-source message broker that enables applications to communicate asynchronously by sending messages via queues.</div>

  <div class="question">2. What messaging protocol does RabbitMQ use?</div>
  <div class="answer">RabbitMQ primarily uses AMQP (Advanced Message Queuing Protocol), but it also supports MQTT, STOMP, and HTTP via plugins.</div>

  <div class="question">3. What are the main components of RabbitMQ?</div>
  <div class="answer">
    - Producer<br>
    - Queue<br>
    - Consumer<br>
    - Exchange<br>
    - Binding
  </div>

  <div class="question">4. What is an exchange in RabbitMQ?</div>
  <div class="answer">An exchange routes messages to queues based on rules defined by bindings. Types: direct, topic, fanout, and headers.</div>

  <div class="question">5. What is a binding?</div>
  <div class="answer">A binding is a link between a queue and an exchange that defines how messages should be routed.</div>

  <div class="question">6. What is a routing key?</div>
  <div class="answer">A routing key is a string used by exchanges to determine how to route a message to queues.</div>

  <div class="question">7. What is the difference between direct and fanout exchanges?</div>
  <div class="answer">
    - Direct: Routes messages to queues with an exact matching routing key.<br>
    - Fanout: Broadcasts messages to all bound queues regardless of routing key.
  </div>

  <div class="question">8. What is a durable queue?</div>
  <div class="answer">A durable queue survives broker restarts. Messages must also be marked as persistent for durability.</div>

  <div class="question">9. What is the difference between persistent and transient messages?</div>
  <div class="answer">Persistent messages are stored to disk and survive broker restarts. Transient messages are stored in memory only.</div>

  <div class="question">10. What is a dead-letter exchange (DLX)?</div>
  <div class="answer">A DLX is used to route messages that are not deliverable or have expired (e.g., rejected, TTL expired).</div>

  <div class="question">11. What is message acknowledgment (ack)?</div>
  <div class="answer">Acknowledgment is a signal sent by the consumer to inform the broker that a message was successfully processed.</div>

  <div class="question">12. What happens if a message is not acknowledged?</div>
  <div class="answer">The message is requeued and redelivered unless auto-ack is enabled or the message is rejected.</div>

  <div class="question">13. What is prefetch count?</div>
  <div class="answer">Prefetch count limits the number of unacknowledged messages sent to a consumer. It’s used for fair dispatching.</div>

  <div class="question">14. How does RabbitMQ ensure message ordering?</div>
  <div class="answer">RabbitMQ ensures ordering within a single queue. Messages are delivered in the order they arrive.</div>

  <div class="question">15. What is the difference between a queue and an exchange?</div>
  <div class="answer">Queues hold messages. Exchanges route messages to queues based on bindings and routing keys.</div>

  <div class="question">16. How does RabbitMQ handle high availability?</div>
  <div class="answer">Using mirrored queues (classic) or quorum queues (recommended), RabbitMQ replicates messages across nodes.</div>

  <div class="question">17. What is a quorum queue?</div>
  <div class="answer">A quorum queue replicates messages across multiple nodes using the Raft consensus algorithm. It replaces mirrored queues.</div>

  <div class="question">18. Can RabbitMQ work with microservices?</div>
  <div class="answer">Yes. RabbitMQ is commonly used in microservice architectures for asynchronous communication between services.</div>

  <div class="question">19. How do you monitor RabbitMQ?</div>
  <div class="answer">Using the RabbitMQ Management Plugin (UI & REST API), Prometheus exporters, or CLI tools like <code>rabbitmqctl</code>.</div>

  <div class="question">20. What are common RabbitMQ client libraries?</div>
  <div class="answer">
    - Node.js: amqplib<br>
    - Python: pika<br>
    - Java: RabbitMQ Java Client<br>
    - .NET: RabbitMQ .NET Client
  </div>

</body>
</html>

</div></li>




<li data-id="kafka"><span class="faq-question green">
  Kafka
  </span><div class="answer">

    <h1></h1>

    <div class="question">1. What is Apache Kafka?</div>
    <div class="answer">Kafka is a distributed event streaming platform used for high-performance data pipelines, streaming analytics, and event-driven applications.</div>
  
    <div class="question">2. What are the main components of Kafka?</div>
    <div class="answer">
      - Producer<br>
      - Consumer<br>
      - Broker<br>
      - Topic<br>
      - Partition<br>
      - Zookeeper (optional for newer versions)
    </div>
  
    <div class="question">3. What is a Kafka topic?</div>
    <div class="answer">A topic is a category/feed name to which records are published. Topics are split into partitions for parallel processing.</div>
  
    <div class="question">4. What is a Kafka partition?</div>
    <div class="answer">A partition is a sub-division of a topic. Each partition is an ordered, immutable sequence of records.</div>
  
    <div class="question">5. What ensures message ordering in Kafka?</div>
    <div class="answer">Kafka guarantees ordering only within a single partition.</div>
  
    <div class="question">6. What is a Kafka broker?</div>
    <div class="answer">A broker is a Kafka server that stores data and serves clients. A cluster has multiple brokers.</div>
  
    <div class="question">7. What is the role of Zookeeper in Kafka?</div>
    <div class="answer">Zookeeper manages Kafka’s metadata, broker coordination, and leader election (older versions). Kafka 2.8+ can run without Zookeeper.</div>
  
    <div class="question">8. What is Kafka Producer?</div>
    <div class="answer">A producer sends records (data) to a Kafka topic.</div>
  
    <div class="question">9. What is Kafka Consumer?</div>
    <div class="answer">A consumer reads records from Kafka topics.</div>
  
    <div class="question">10. What is a Consumer Group?</div>
    <div class="answer">A group of consumers that share the load of reading from topics. Each partition is read by only one consumer in the group.</div>
  
    <div class="question">11. How does Kafka ensure fault tolerance?</div>
    <div class="answer">Through replication: each partition has replicas. If the leader fails, a follower takes over.</div>
  
    <div class="question">12. What is Kafka's retention policy?</div>
    <div class="answer">Kafka retains messages for a configurable amount of time or until a storage size limit is reached, even if consumed.</div>
  
    <div class="question">13. How does Kafka achieve high throughput?</div>
    <div class="answer">Through sequential disk writes, zero-copy, batching, and compression.</div>
  
    <div class="question">14. What are Kafka delivery semantics?</div>
    <div class="answer">
      - At most once<br>
      - At least once<br>
      - Exactly once (since Kafka 0.11+)
    </div>
  
    <div class="question">15. What is idempotence in Kafka?</div>
    <div class="answer">It ensures the same message is not duplicated if sent multiple times. Enabled via idempotent producers.</div>
  
    <div class="question">16. What is a Kafka offset?</div>
    <div class="answer">A unique identifier of a record within a partition. Consumers track offsets to resume reading.</div>
  
    <div class="question">17. How is offset management done?</div>
    <div class="answer">Offsets can be committed automatically or manually, and are stored in Kafka’s __consumer_offsets topic.</div>
  
    <div class="question">18. What are Kafka Streams?</div>
    <div class="answer">Kafka Streams is a client library for building real-time applications using Kafka topics as input/output.</div>
  
    <div class="question">19. What is the difference between Kafka and a traditional message queue?</div>
    <div class="answer">
      Kafka stores data for a time period regardless of consumption and supports replaying messages.<br>
      Queues typically delete messages once consumed.
    </div>
  
    <div class="question">20. What is the role of schema registry in Kafka?</div>
    <div class="answer">Schema registry ensures that producers and consumers agree on data format (e.g., using Avro schemas).</div>
  
</div></li>

<li data-id="kafka"><span class="faq-question green">
  Kafka Example***
  </span><div class="answer">
    <h1>✅ NestJS + KafkaJS with Online Kafka Server</h1>

    <h2>📦 Prerequisites</h2>
    <ul>
      <li>Install NestJS CLI:</li>
      <pre><code>npm i -g @nestjs/cli</code></pre>
      <li>Install KafkaJS:</li>
      <pre><code>npm install kafkajs</code></pre>
      <li>Kafka server: Use Confluent Cloud or CloudKarafka (free tiers work)</li>
    </ul>
  
    <h2>📁 Project Setup</h2>
    <pre><code>nest new kafka-nestjs-app
  cd kafka-nestjs-app
  npm install kafkajs</code></pre>
  
    <h2>🛠️ Kafka Service File</h2>
    <p><code>src/kafka.service.ts</code></p>
    <pre><code>
  import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common';
  import { Kafka, Producer, Consumer } from 'kafkajs';
  
  @Injectable()
  export class KafkaService implements OnModuleInit, OnModuleDestroy {
    private kafka: Kafka;
    private producer: Producer;
    private consumer: Consumer;
  
    async onModuleInit() {
      this.kafka = new Kafka({
        clientId: 'nestjs-client',
        brokers: ['&lt;BROKER_URL&gt;'], // e.g. pkc-xxxx.gcp.confluent.cloud:9092
        ssl: true,
        sasl: {
          mechanism: 'plain',
          username: '&lt;API_KEY&gt;',
          password: '&lt;API_SECRET&gt;',
        },
      });
  
      this.producer = this.kafka.producer();
      await this.producer.connect();
  
      this.consumer = this.kafka.consumer({ groupId: 'nestjs-group' });
      await this.consumer.connect();
      await this.consumer.subscribe({ topic: 'test-topic', fromBeginning: true });
  
      await this.consumer.run({
        eachMessage: async ({ topic, partition, message }) => {
          console.log(`Received: ${message.value.toString()}`);
        },
      });
    }
  
    async sendMessage(topic: string, message: any) {
      await this.producer.send({
        topic,
        messages: [{ value: JSON.stringify(message) }],
      });
    }
  
    async onModuleDestroy() {
      await this.producer.disconnect();
      await this.consumer.disconnect();
    }
  }
    </code></pre>
  
    <h2>🧩 App Module</h2>
    <p><code>src/app.module.ts</code></p>
    <pre><code>
  import { Module } from '@nestjs/common';
  import { KafkaService } from './kafka.service';
  
  @Module({
    providers: [KafkaService],
  })
  export class AppModule {}
    </code></pre>
  
    <h2>🚀 App Controller</h2>
    <p><code>src/app.controller.ts</code></p>
    <pre><code>
  import { Controller, Get } from '@nestjs/common';
  import { KafkaService } from './kafka.service';
  
  @Controller()
  export class AppController {
    constructor(private readonly kafkaService: KafkaService) {}
  
    @Get('send')
    async sendMessage() {
      await this.kafkaService.sendMessage('test-topic', { message: 'Hello Kafka' });
      return 'Message sent';
    }
  }
    </code></pre>
  
    <h2>▶️ Run the App</h2>
    <pre><code>npm run start</code></pre>
    <p>Then visit <code>http://localhost:3000/send</code> to test Kafka message sending.</p>
  
    <h2>🔒 Tips</h2>
    <ul>
      <li>Make sure your Kafka broker supports SSL + SASL.</li>
      <li>Replace <code>&lt;BROKER_URL&gt;</code>, <code>&lt;API_KEY&gt;</code>, <code>&lt;API_SECRET&gt;</code> with real credentials.</li>
      <li>Use free cloud Kafka providers for convenience.</li>
    </ul>
  
    <h2>📚 Resources</h2>
    <ul>
      <li><a href="https://docs.nestjs.com/microservices/kafka" target="_blank">NestJS Kafka Docs</a></li>
      <li><a href="https://kafka.js.org/docs" target="_blank">KafkaJS Docs</a></li>
      <li><a href="https://www.confluent.io/cloud/" target="_blank">Confluent Cloud</a></li>
      <li><a href="https://www.cloudkarafka.com/" target="_blank">CloudKarafka</a></li>
    </ul>
  

    </div></li>







    <li data-id="q_call_api_without_useeffect"><span class="faq-question green">
      AWS Lambda
      </span><div class="answer">
      
      <ol>
        <li><strong>What is AWS Lambda?</strong></li>
        <li><strong>What are the key features of AWS Lambda?</strong></li>
        <li><strong>How does AWS Lambda pricing work?</strong></li>
        <li><strong>What triggers can invoke a Lambda function?</strong></li>
        <li><strong>What are the supported languages in AWS Lambda?</strong></li>
        <li><strong>What is the maximum execution time of a Lambda function?</strong></li>
        <li><strong>How do you monitor a Lambda function?</strong></li>
        <li><strong>What is a cold start in AWS Lambda?</strong></li>
        <li><strong>How can you reduce cold start time?</strong></li>
        <li><strong>What is the difference between synchronous and asynchronous invocation?</strong></li>
        <li><strong>How does concurrency work in Lambda?</strong></li>
        <li><strong>What is the default memory limit and how can it be changed?</strong></li>
        <li><strong>How do you handle errors in AWS Lambda?</strong></li>
        <li><strong>Can a Lambda function call another Lambda function?</strong></li>
        <li><strong>How do you version and alias a Lambda function?</strong></li>
        <li><strong>What is Lambda@Edge?</strong></li>
        <li><strong>What is the difference between Lambda and EC2?</strong></li>
        <li><strong>How do you deploy a Lambda function?</strong></li>
        <li><strong>How can environment variables be used in Lambda?</strong></li>
        <li><strong>How does IAM relate to Lambda function permissions?</strong></li>
        <li><strong>What is the Lambda execution role?</strong></li>
        <li><strong>How can you connect Lambda to VPC?</strong></li>
        <li><strong>How do you integrate AWS Lambda with API Gateway?</strong></li>
        <li><strong>What is the use of the Lambda Layers feature?</strong></li>
        <li><strong>What is the difference between Lambda and Step Functions?</strong></li>
      </ol>
      --------------------------------
      </div></li>
    
      <li data-id="q_what_is_lambda">
        <span class="faq-question">What is AWS Lambda?</span>
        <div class="answer">
          AWS Lambda is a serverless compute service that lets you run code without provisioning or managing servers. You simply upload your function code, and Lambda handles the rest—scaling, monitoring, patching, and running your application in response to events.
        </div>
      </li>
      
      <li data-id="q_lambda_features">
        <span class="faq-question">What are the key features of AWS Lambda?</span>
        <div class="answer">
          Key features of AWS Lambda include:
          <ul>
            <li>No server management</li>
            <li>Automatic scaling</li>
            <li>Sub-second metering (pay only for usage)</li>
            <li>Event-driven invocation (triggers from over 200 AWS services)</li>
            <li>Built-in fault tolerance</li>
            <li>Supports environment variables, versioning, and aliases</li>
            <li>Integration with VPC, Layers, and Container Images</li>
          </ul>
        </div>


        <div class="answer">
          AWS Lambda provides a powerful and flexible serverless compute platform. Its key features include:
          <ul>
            <li><strong>Event-Driven Execution:</strong> Automatically triggered by AWS services (e.g., S3, API Gateway, DynamoDB) or external events.</li>
            <li><strong>No Server Management:</strong> No need to provision or manage infrastructure. AWS handles everything.</li>
            <li><strong>Automatic Scaling:</strong> Lambda scales automatically with the number of incoming events.</li>
            <li><strong>Pay-per-Use Pricing:</strong> Billed per millisecond based on the number of requests and compute time used.</li>
            <li><strong>Supports Multiple Languages:</strong> Includes Node.js, Python, Go, Java, .NET, Ruby, and custom runtimes.</li>
            <li><strong>Short-Lived Functions:</strong> Functions run up to 15 minutes and then terminate automatically.</li>
            <li><strong>Built-in Monitoring:</strong> Integrated with CloudWatch for logs and metrics.</li>
            <li><strong>Environment Variables:</strong> Store configuration and secrets per environment (e.g., dev, prod).</li>
            <li><strong>Versioning & Aliases:</strong> Create immutable versions of code and route traffic with named aliases.</li>
            <li><strong>VPC Support:</strong> Access private resources in a VPC securely.</li>
            <li><strong>Provisioned Concurrency:</strong> Pre-warm instances to avoid cold starts for latency-sensitive workloads.</li>
            <li><strong>Lambda Layers:</strong> Package and share libraries or dependencies across multiple functions.</li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_lambda_pricing">
        <span class="faq-question">How does AWS Lambda pricing work?</span>
        <div class="answer">
          AWS Lambda charges are based on:
          <ul>
            <li><strong>Number of requests:</strong> First 1 million requests/month are free. After that, it's $0.20 per million requests.</li>
            <li><strong>Duration:</strong> Billed per millisecond from the time your code begins executing until it returns or otherwise terminates. Depends on the memory allocated.</li>
          </ul>
          Example: If your function runs for 200ms and uses 128MB memory, you only pay for that exact duration and size.
        </div>
      </li>
      
      <li data-id="q_lambda_triggers">
        <span class="faq-question">What triggers can invoke a Lambda function?</span>
        <div class="answer">
          Lambda can be triggered by various AWS services, including:
          <ul>
            <li>API Gateway (HTTP requests)</li>
            <li>S3 (file uploads, deletions)</li>
            <li>DynamoDB Streams</li>
            <li>SNS (notifications)</li>
            <li>SQS (queues)</li>
            <li>CloudWatch Events & Logs</li>
            <li>Cognito, Alexa Skills, EventBridge, etc.</li>
          </ul>
          Lambda can also be triggered manually using the AWS SDK or CLI.
        </div>
      </li>
      
      <li data-id="q_lambda_languages">
        <span class="faq-question">What are the supported languages in AWS Lambda?</span>
        <div class="answer">
          AWS Lambda natively supports:
          <ul>
            <li>Node.js</li>
            <li>Python</li>
            <li>Java</li>
            <li>Go</li>
            <li>C# (.NET Core)</li>
            <li>Ruby</li>
          </ul>
          It also supports custom runtimes and container images, allowing you to use any language.
        </div>
      </li>
      
      <li data-id="q_lambda_timeout">
        <span class="faq-question">What is the maximum execution time of a Lambda function?</span>
        <div class="answer">
          The maximum timeout for a Lambda function is <strong>15 minutes (900 seconds)</strong> per invocation. You can configure the timeout in the Lambda function settings depending on your use case.
        </div>
      </li>
      
      <li data-id="q_lambda_monitoring">
        <span class="faq-question">How do you monitor a Lambda function?</span>
        <div class="answer">
          Lambda integrates with AWS CloudWatch to provide monitoring:
          <ul>
            <li><strong>CloudWatch Logs:</strong> Automatically captures console output and errors.</li>
            <li><strong>CloudWatch Metrics:</strong> Tracks invocation count, duration, error count, throttles, and more.</li>
            <li><strong>CloudWatch Alarms:</strong> Trigger notifications based on metric thresholds.</li>
            <li><strong>X-Ray:</strong> For distributed tracing and performance analysis.</li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_call_api_without_useeffect">
        <span class="faq-question">What is a cold start in AWS Lambda?</span>
        <div class="answer">
          A cold start occurs when AWS needs to create a new container to run your Lambda function—for example, when there's no existing warm instance available. It includes the time taken to:
          <ul>
            <li>Provision the runtime container</li>
            <li>Download your function code</li>
            <li>Initialize dependencies</li>
          </ul>
          Cold starts introduce extra latency (usually 100ms–1s). They are more noticeable with VPC-configured or infrequently used functions.
        </div>
      </li>
      
      <li data-id="q_lambda_cold_start_optimization">
        <span class="faq-question">How can you reduce cold start time?</span>
        <div class="answer">
          You can reduce cold start time in AWS Lambda by:
          <ul>
            <li>Using lighter runtimes like Node.js or Go (faster startup)</li>
            <li>Minimizing initialization code and package size</li>
            <li>Keeping functions warm using scheduled CloudWatch Events</li>
            <li>Avoiding VPC connections unless required (or optimizing them)</li>
            <li>Using Provisioned Concurrency (pre-warms containers to eliminate cold starts)</li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_lambda_sync_async">
        <span class="faq-question">What is the difference between synchronous and asynchronous invocation?</span>
        <div class="answer">
          <strong>Synchronous Invocation:</strong> Caller waits for the function to process and return a result. Example: API Gateway.<br />
          <strong>Asynchronous Invocation:</strong> Caller sends the request and continues without waiting for a response. Example: S3 or SNS.<br />
          <strong>Differences:</strong>
          <ul>
            <li>Synchronous = real-time; Asynchronous = event-based</li>
            <li>Synchronous errors are returned immediately; asynchronous are logged</li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_lambda_concurrency">
        <span class="faq-question">How does concurrency work in Lambda?</span>
        <div class="answer">
          Concurrency is the number of instances that can run in parallel:
          <ul>
            <li><strong>Unreserved concurrency:</strong> Default limit shared across functions (e.g. 1000)</li>
            <li><strong>Reserved concurrency:</strong> Guarantees a specific number of concurrent executions for a function</li>
            <li><strong>Provisioned concurrency:</strong> Keeps containers initialized and ready to respond instantly</li>
          </ul>
          If concurrency limit is hit, excess requests are throttled.
        </div>
      </li>
      
      <li data-id="q_lambda_memory">
        <span class="faq-question">What is the default memory limit and how can it be changed?</span>
        <div class="answer">
          <strong>Default Memory:</strong> 128 MB<br />
          <strong>Range:</strong> 128 MB to 10,240 MB (10 GB), in 1 MB increments.<br />
          You can change it from:
          <ul>
            <li>AWS Console &rarr; Lambda &rarr; Configuration &rarr; Memory</li>
            <li>Or via CLI: <code>aws lambda update-function-configuration</code></li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_lambda_errors">
        <span class="faq-question">How do you handle errors in AWS Lambda?</span>
        <div class="answer">
          You can handle errors in Lambda using:
          <ul>
            <li><strong>Try-catch blocks:</strong> Handle exceptions in your code</li>
            <li><strong>Return meaningful error responses (for synchronous calls)</strong></li>
            <li><strong>Dead Letter Queues (DLQs):</strong> Capture failed async invocations</li>
            <li><strong>CloudWatch Logs:</strong> View stack traces and error details</li>
            <li><strong>Retries:</strong> Lambda automatically retries failed async events (2 times by default)</li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_lambda_calls_lambda">
        <span class="faq-question">Can a Lambda function call another Lambda function?</span>
        <div class="answer">
          Yes, a Lambda function can invoke another Lambda using the AWS SDK or AWS CLI. This is useful for microservice architectures or function chaining.<br />
          Example in Node.js:
          <pre><code>
      const AWS = require('aws-sdk');
      const lambda = new AWS.Lambda();
      lambda.invoke({
        FunctionName: 'anotherLambdaFunction',
        Payload: JSON.stringify({ key: 'value' })
      }, (err, data) => { ... });
          </code></pre>
          Make sure the calling Lambda has the IAM permission <code>lambda:InvokeFunction</code>.
        </div>
      </li>
      
      <li data-id="q_lambda_version_alias">
        <span class="faq-question">How do you version and alias a Lambda function?</span>
        <div class="answer">
          <strong>Versioning:</strong> Every time you publish a function version, AWS creates an immutable snapshot of the code and configuration.<br />
          <strong>Alias:</strong> Acts as a pointer to a specific version. Useful for traffic shifting (e.g., <code>prod</code>, <code>beta</code> aliases).<br />
          Example:
          <ul>
            <li><code>$LATEST</code> → Draft code</li>
            <li><code>1</code>, <code>2</code>, etc. → Published versions</li>
            <li><code>alias: prod → version: 5</code></li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_call_api_without_useeffect">
        <span class="faq-question">What is Lambda@Edge?</span>
        <div class="answer">
          Lambda@Edge is an extension of AWS Lambda that lets you run functions at AWS edge locations. It's integrated with Amazon CloudFront and is used for:
          <ul>
            <li>Customizing CDN content before it's delivered</li>
            <li>Implementing security/auth at the edge</li>
            <li>Personalizing content based on headers, cookies, etc.</li>
            <li>Modifying requests/responses without origin call</li>
          </ul>
          It improves performance and reduces latency by moving compute closer to the user.
        </div>
      </li>
      
    
      <li data-id="q_lambda_vs_ec2">
        <span class="faq-question">What is the difference between Lambda and EC2?</span>
        <div class="answer">
          <strong>AWS Lambda:</strong> Serverless, event-driven compute service. No server management; pay-per-invocation.<br />
          <strong>EC2:</strong> Virtual server in the cloud. You manage OS, scaling, patching.<br /><br />
          <strong>Key Differences:</strong>
          <ul>
            <li>Lambda is event-based; EC2 is instance-based</li>
            <li>Lambda scales automatically; EC2 needs manual or auto-scaling setup</li>
            <li>Lambda is billed per millisecond; EC2 is billed per second or hour</li>
            <li>Lambda can't be used for long-running tasks (max 15 minutes); EC2 can run indefinitely</li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_lambda_deploy">
        <span class="faq-question">How do you deploy a Lambda function?</span>
        <div class="answer">
          You can deploy a Lambda function using:
          <ul>
            <li><strong>AWS Console:</strong> Upload .zip or use inline editor</li>
            <li><strong>AWS CLI:</strong> Use <code>aws lambda create-function</code> or <code>update-function-code</code></li>
            <li><strong>Infrastructure as Code:</strong> Tools like AWS SAM, Serverless Framework, Terraform, or CloudFormation</li>
            <li><strong>CI/CD Pipelines:</strong> Using CodePipeline, GitHub Actions, or Jenkins</li>
          </ul>
        </div>
      </li>
      
      <li data-id="q_lambda_env">
        <span class="faq-question">How can environment variables be used in Lambda?</span>
        <div class="answer">
          Lambda supports environment variables to:
          <ul>
            <li>Store config values (DB URLs, API keys, etc.)</li>
            <li>Separate environment-specific settings (dev, test, prod)</li>
          </ul>
          <strong>Access:</strong> Use <code>process.env.VARIABLE_NAME</code> in your function code.<br />
          <strong>Security:</strong> You can encrypt them using KMS and manage access with IAM policies.
        </div>
      </li>
      
      <li data-id="q_lambda_iam">
        <span class="faq-question">How does IAM relate to Lambda function permissions?</span>
        <div class="answer">
          AWS IAM (Identity and Access Management) controls who can:
          <ul>
            <li>Create, modify, delete Lambda functions</li>
            <li>Assign permissions to Lambda functions</li>
            <li>Invoke functions or access resources Lambda interacts with</li>
          </ul>
          Lambda uses <strong>execution roles</strong> (IAM roles) to interact with other AWS services securely.
        </div>
      </li>
      
      <li data-id="q_lambda_exec_role">
        <span class="faq-question">What is the Lambda execution role?</span>
        <div class="answer">
          The execution role is an IAM role assumed by the Lambda function at runtime. It defines:
          <ul>
            <li>Which AWS services the function can access (e.g., S3, DynamoDB)</li>
            <li>Permission to write logs to CloudWatch</li>
          </ul>
          <strong>Policy Example:</strong>
          <pre><code>{
        "Effect": "Allow",
        "Action": ["s3:GetObject", "logs:CreateLogStream"],
        "Resource": "*"
      }</code></pre>
        </div>
      </li>
      
      <li data-id="q_lambda_vpc">
        <span class="faq-question">How can you connect Lambda to VPC?</span>
        <div class="answer">
          Lambda can access private VPC resources (e.g., RDS, EC2) by assigning:
          <ul>
            <li>VPC ID</li>
            <li>Subnets with NAT Gateway (for internet access)</li>
            <li>Security groups (to control access)</li>
          </ul>
          This allows your Lambda to operate securely within your VPC.
        </div>
      </li>
      
      <li data-id="q_lambda_apigw">
        <span class="faq-question">How do you integrate AWS Lambda with API Gateway?</span>
        <div class="answer">
          You can expose your Lambda function via REST or HTTP APIs using API Gateway:
          <ul>
            <li>Create a REST API in API Gateway</li>
            <li>Define resources and methods (e.g., GET /users)</li>
            <li>Set integration type as Lambda function</li>
            <li>Deploy the API to a stage (e.g., /prod)</li>
          </ul>
          This setup allows clients to invoke Lambda functions over HTTPS.
        </div>
      </li>
      
      <li data-id="q_lambda_layers">
        <span class="faq-question">What is the use of the Lambda Layers feature?</span>
        <div class="answer">
          Lambda Layers are a way to package and reuse shared code or dependencies across multiple functions. Use cases:
          <ul>
            <li>Third-party libraries (e.g., bcrypt, pandas)</li>
            <li>Custom utility modules</li>
            <li>Large binaries or compiled packages</li>
          </ul>
          <strong>Benefits:</strong> Reduces deployment size and duplication across functions.
        </div>
      </li>
      
      <li data-id="q_lambda_vs_stepfunctions">
        <span class="faq-question">What is the difference between Lambda and Step Functions?</span>
        <div class="answer">
          <strong>AWS Lambda:</strong> Executes single tasks triggered by events.<br />
          <strong>AWS Step Functions:</strong> Orchestrates multiple AWS services/functions in workflows with logic.<br />
          <strong>Comparison:</strong>
          <ul>
            <li>Lambda = compute unit; Step Functions = workflow engine</li>
            <li>Step Functions handle retries, timeouts, branching, error catching</li>
            <li>Useful for building complex apps like ETL pipelines, order processing, etc.</li>
          </ul>
        </div>
      </li>
      













<li data-id="q3"><span class="faq-question">---------------------------------------</span><br /><span class="faq-question">---------------------------------------</span></li>    
<li data-id="q3"><span class="faq-question">
a == b ?
</span><div class="answer">
const a = { name: "Ram" };<br />
const b = { name: "Ram" };<br />
console.log(a == b); // false<br />
JSON.stringify(a) === JSON.stringify(b); // true<br />
const _ = require('lodash');<br />
_.isEqual(a, b); // true<br />
</div></li>
    

<li data-id="q3"><span class="faq-question">---------------------------------------</span><br /><span class="faq-question">---------------------------------------</span></li>    
<li data-id="q3"><span class="faq-question">
What are the key features of Node.js?
</span><div class="answer">
Key features include asynchronous and event-driven architecture, single-threaded model, fast execution via V8 engine, non-blocking I/O, npm (Node package manager), and the ability to build scalable network applications.
</div></li>

<li data-id="q4"><span class="faq-question">
Difference between require() and import?
</span><div class="answer">
`require()` is CommonJS syntax used in Node.js; it loads modules synchronously. `import` is ES6 syntax, used with modules, supports static analysis, and is asynchronous. `import` requires `"type": "module"` in `package.json`.
</div></li>


<li data-id="q6"><span class="faq-question">
non-blocking I/O?
</span><div class="answer">
Non-blocking I/O allows Node.js to continue executing other code while waiting for I/O operations (like reading files or querying databases) to complete, improving efficiency and scalability.
</div></li>

<li data-id="q7"><span class="faq-question">
How do you handle asynchronous code in Node.js?
</span><div class="answer">
Asynchronous code can be handled using callbacks, Promises, or `async/await`. These techniques prevent blocking the event loop and ensure smooth execution of concurrent tasks.
</div></li>




<li data-id="q10"><span class="faq-question">
the purpose of package.json?
</span><div class="answer">
`package.json` holds metadata about a Node.js project, including dependencies, scripts, version, main file, and more. It helps manage packages and project configuration.
</div></li>

<li data-id="q11"><span class="faq-question">
Explain the EventEmitter in Node.js.
</span><div class="answer">
`EventEmitter` is a core Node.js module that facilitates communication via events. You can create custom events using `emit()` and subscribe using `on()` or `once()`.
</div></li>







<li data-id="q15"><span class="faq-question">
How do you implement authentication in Node.js (e.g., JWT)?
</span><div class="answer">
Use `jsonwebtoken` to issue and verify JWT tokens. On login, generate a token and send it to the client. For protected routes, use middleware to verify the token.
</div></li>

<li data-id="q16"><span class="faq-question">
What are memory leaks in Node.js and how can you prevent them?
</span><div class="answer">
Memory leaks occur when memory is not released. Common causes include unused references, event listeners, or closures. Use tools like `clinic`, `heapdump`, and `--inspect` to detect and prevent them.
</div></li>

<li data-id="q17"><span class="faq-question">
How do you manage environment variables in Node.js?
</span><div class="answer">
Use `.env` files with the `dotenv` package. Load variables using `require('dotenv').config()` and access them via `process.env.VARIABLE_NAME`.
</div></li>

<li data-id="q18"><span class="faq-question">
the difference between spawn(), exec(), and fork()?
</span><div class="answer">
- `spawn()`: launches a new process, streams output.  
- `exec()`: buffers entire output in memory.  
- `fork()`: spawns a new Node.js process with IPC for communication.
</div></li>




<li data-id="q21"><span class="faq-question">
How does Node.js handle async I/O under the hood (libuv)?
</span><div class="answer">
libuv is a C library that manages thread pool and async I/O. It delegates I/O operations to the OS or internal threads and notifies Node.js when operations complete.
</div></li>



<li data-id="q23"><span class="faq-question">
backpressure in Node.js streams and how to handle it?
</span><div class="answer">
Backpressure occurs when the writable stream can't handle the data speed of a readable stream. Use `stream.pause()`, `drain` events, and `pipe()` for flow control.
</div></li>


<li data-id="q25"><span class="faq-question">
Explain process-level error handling (uncaughtException, unhandledRejection).
</span><div class="answer">
`process.on('uncaughtException')` and `process.on('unhandledRejection')` catch unhandled errors globally. Prefer local error handling; use these for logging and graceful shutdowns.
</div></li>

<li data-id="q26"><span class="faq-question">
How to implement custom events using EventEmitter?
</span><div class="answer">
Create an `EventEmitter` instance, emit events using `.emit('eventName', data)`, and listen using `.on('eventName', callback)`. Useful for decoupling logic.
</div></li>

<li data-id="q27"><span class="faq-question">
What are the differences between microservices and monoliths in a Node.js context?
</span><div class="answer">
Monoliths bundle all logic in one app. Microservices split features into independent services communicating via APIs or messages. Microservices are scalable, but complex to manage.
</div></li>



<li data-id="q29"><span class="faq-question">
Explain the concept of middleware chaining in Express.js.
</span><div class="answer">
Middleware chaining lets multiple functions process a request sequentially. Each middleware calls `next()` to pass control. Useful for validations, authentication, and logging.
</div></li>

<li data-id="q30"><span class="faq-question">
a memory heap and how do you analyze it in Node.js?
</span><div class="answer">
A memory heap is the area where memory is allocated for objects. Analyze it using Chrome DevTools, Node.js `--inspect` flag, or memory profiling tools like `heapdump`.
</div></li>




<li data-id="q_call_api_after_unmount"><span class="faq-question">
How to call an API after a React component unmounts?
</span><div class="answer">
Calling an API <em>after</em> a component unmounts is generally discouraged because the component no longer exists to handle the response.

However, if needed, you can trigger a side effect in the cleanup function of <code>useEffect</code>:

<pre><code>
useEffect(() => {
return () => {
// Cleanup function called on unmount
fetch('/api/endpoint', { method: 'POST' })
.then(res => console.log('API called on unmount'))
.catch(err => console.error(err));
};
}, []);
</code></pre>

Note: The API call may be canceled if the component unmounts abruptly, so it’s better handled outside React, e.g., in global state or services.
</div></li>


<li data-id="q_call_api_without_useeffect"><span class="faq-question">
How to call an API without using useEffect in React?
</span><div class="answer">
You can call an API without <code>useEffect</code> by triggering the fetch inside event handlers, lifecycle methods (class components), or directly within functions.

Examples:

1. Inside an event handler (e.g., onClick):
<pre><code>
function MyComponent() {
const fetchData = () => {
fetch('/api/data')
.then(res => res.json())
.then(data => console.log(data));
};

return &lt;button onClick={fetchData}&gt;Fetch Data&lt;/button&gt;;
}
</code></pre>

2. In class components, call API in <code>componentDidMount()</code> instead of <code>useEffect</code>.

Direct API calls in render are discouraged to avoid repeated calls on every render.
</div></li>



<li data-id="q_call_api_without_useeffect"><span class="faq-question222">------------------------------------------<br />-----------------------------
</span><div class="answer"></div></li>







<li data-id="q_call_api_without_useeffect"><span class="faq-question232">------------------------------------------<br />-----------------------------
</span><div class="answer"></div></li>
<li data-id="q_call_api_without_useeffect"><span class="faq-question234234">------------------------------------------<br />-----------------------------
</span><div class="answer"></div></li>


</ul>


<script src="script.js"></script>

</body>
</html>
