<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FAQ</title>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.1/dist/js.cookie.min.js"></script>
<link rel="stylesheet" href="styles.css">
</head>
<body>


<ul class="faq">



<li data-id="q1"><span class="faq-question">ReactJS </span><div class="answer">


What is the significance of key props in lists?<br />
What are functional components?<br />
What are class components?<br />
What are the different phases of the component lifecycle?<br />
What lifecycle methods are used for side effects?<br />
When would you use componentDidUpdate()?<br />
What is the Context API and how does it work?<br />
How does code-splitting work in React?<br />


</div></li>


<li data-id="q3"><span class="faq-question">---------------------------------------</span><br /><span class="faq-question">---------------------------------------</span></li>  
<li data-id="q3"><span class="faq-question">---------------------------------------</span><br /><span class="faq-question">---------------------------------------</span></li>  


<li data-id="q_reconciliation"><span class="faq-question">
Reconciliation?
</span><div class="answer">
Reconciliation is the process React uses to update the DOM efficiently when the state or props of a component change.

Instead of re-rendering the entire UI, React:
<ol class="subul">
<li>Uses the <b>Virtual DOM</b> to represent the current state of the UI.</li>
<li>Compares the new Virtual DOM with the previous one using a <b>diffing algorithm</b>.</li>
<li>Calculates the minimal number of changes needed.</li>
<li>Updates only the changed parts in the real DOM.</li>
</ol>


<b>Example:</b> If only one item in a list changes, React will update that item instead of re-rendering the entire list.
<br />
<b>Benefits:</b>
- Improves performance.
- Avoids full page refresh.
- Provides smooth user experiences by minimizing DOM operations.

This efficient update process is what makes React fast and responsive.
</div></li>




<li data-id="q1"><span class="faq-question">
React?
</span><div class="answer">
<ol class="subul">
<li><b>React</b> is a JavaScript library developed by Facebook for building user interfaces, especially for single-page applications. It allows developers to create reusable UI components.</li>
<li><b>Components</b> are the building blocks of a React application. They can be functional or class-based, and each component represents a part of the UI.</li>
<li><b>JSX</b> (JavaScript XML) is a syntax extension that allows writing HTML inside JavaScript. It makes the code more readable and easier to write React elements.</li>
<li><b>Reconciliation</b> React compares the new virtual DOM with the previous one using a diffing algorithm and updates only the parts of the DOM that changed (this process is called reconciliation).</li>

<li><b>Controlled Components :</b> form elements whose values are controlled by React state.</li>
<li><b>Uncontrolled components :</b> form elements that maintain their state using the DOM (accessed via refs).</li>


<li><b>useState() : </b>The <code>useState()</code> hook is used in React functional components to manage local state. It allows you to store, read, and update values across re-renders.
    <br />
    This enables your component to reactively update the UI based on user interactions or other changes.
    </li>
    
    <li><b>Prop Drilling : </b>Prop Drilling refers to the process of passing data from a parent component down to child components, and then further down to deeply nested components, even if intermediate components don’t need that data. It becomes problematic when the component tree is large, leading to tight coupling and making components harder to manage and maintain.
    </li>
    
    
    <li><b>defaultProps : </b>
    
        is a feature in React that allows you to define default values for a component’s props. If a parent component does not provide a specific prop, the default value will be used instead. It helps prevent bugs and ensures components behave as expected even if some props are not passed.<br />
        
        Usage (for functional components):<br />
        <pre><code>
        const Greeting = ({ name = "Guest" }) =&gt; (
        &lt;h1&gt;Hello, {name}&lt;/h1&gt;
        );
        </code></pre>
        </li>


</ol>
</div></li>

<li data-id="q1"><span class="faq-question">
Commonly used hooks.
</span><div class="answer">
<ol class="subul">
<li><strong>useState</strong></li>
<li><strong>useEffect</strong> runs after painting the DOM.</li>
<li><strong>useContext</strong></li>
<li><strong>useReducer</strong></li>
<li><strong>useCallback : </strong>Returns a memoized version of a function that only changes if dependencies change — useful for preventing unnecessary re-renders.</li>
<li><strong>useMemo : </strong> memoizes the result of a function to avoid recalculating it. Memoizes a computed value, recalculating it only when dependencies change.</li>
<li><strong>useReducer : </strong> An alternative to useState for managing complex state logic.</li>
<li><strong>useRef : </strong></li>
<li><strong>useLayoutEffect : </strong> runs synchronously before the DOM is painted — useful for layout measurements or DOM mutations.</li>
<li><strong>useImperativeHandle</strong></li>
<li><strong>useDebugValue</strong></li>
</ol>
<br />
</div></li>



<li data-id="q_hoc"><span class="faq-question">
HOC?
</span><div class="answer">
A Higher-Order Component (HOC) is an advanced pattern in React used to reuse component logic. It’s a function that takes a component and returns a new component with added functionality.

<br><br><strong>Syntax:</strong><br>
<pre><code>
const withExtraProps = (WrappedComponent) => {
return (props) => &lt;WrappedComponent {...props} extra="value" /&gt;;
};
</code></pre>

<br><strong>Use Cases:</strong><br>
<ul>
<li>Authentication</li>
<li>Logging</li>
<li>Theming or Localization</li>
<li>Permission Checks</li>
</ul>

<br><strong>Example:</strong><br>
<pre><code>
const withLogger = (WrappedComponent) => {
return (props) => {
console.log('Props:', props);
return &lt;WrappedComponent {...props} /&gt;;
};
};

const MyComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;

export default withLogger(MyComponent);
</code></pre>

<br><strong>Main Use:</strong><br>
To reuse logic across multiple components without duplicating code.

<br><br><strong>HOC vs Alternatives:</strong><br>
<ul>
<li><strong>HOC:</strong> Wraps and returns enhanced component.</li>
<li><strong>Render Props:</strong> Uses a function to determine what to render.</li>
<li><strong>Custom Hooks:</strong> Encapsulates reusable logic using <code>useXYZ</code>.</li>
</ul>
</div></li>


<li data-id="q1"><span class="faq-question">
Component Lifecycle
</span><div class="answer">
React class components have 3 main lifecycle phases:
<ol class="subul">
<li><b>Mounting</b> (Component is being created and inserted into the DOM)</li>
<li><b>Updating</b> (Component is re-rendered due to prop or state changes)</li>
<li><b>Unmounting</b> (Component is removed from the DOM</li>
</ol>
<br />
</div></li>

<li data-id="q_react_vs_reactdom"><span class="faq-question">
React Vs ReactDOM?
</span><div class="answer">
<strong>React</strong> and <strong>ReactDOM</strong> are two separate libraries in the React ecosystem, each with a distinct purpose:

<br><br><strong>React:</strong><br>
- React is the core library for building component-based user interfaces.
- It provides methods like <code>React.createElement()</code>, <code>useState()</code>, and <code>useEffect()</code> for component logic.
- It’s platform-agnostic, meaning it doesn’t assume the environment (browser, mobile, etc.).

<br><br><strong>ReactDOM:</strong><br>
- ReactDOM is the library that specifically handles rendering React components to the DOM (i.e., web browsers).
- It includes methods like <code>ReactDOM.createRoot()</code> and <code>ReactDOM.render()</code>.
- It bridges React with the actual DOM for web applications.

<br><br><strong>In Summary:</strong><br>
- Use <strong>React</strong> for building components and managing logic.
- Use <strong>ReactDOM</strong> for mounting React components to the web page.
</div></li>



<li data-id="q_react_performance"><span class="faq-question">
How can you improve performance in a React application?
</span><div class="answer">
Improving performance in a React application involves multiple strategies to minimize re-renders, optimize rendering behavior, and reduce resource usage.

<br><br><strong>Key Techniques:</strong>
<ol class="subul">
<li><strong>Memoization:</strong> Use <code>React.memo</code> for components and <code>useMemo</code> for values to avoid unnecessary recalculations.</li>
<li><strong>useCallback:</strong> Prevents re-creation of functions during re-renders.</li>
<li><strong>Code Splitting:</strong> Use <code>React.lazy</code> and <code>Suspense</code> to load components on demand.</li>
<li><strong>Virtualization:</strong> Libraries like <code>react-window</code> or <code>react-virtualized</code> render only visible items in long lists.</li>
<li><strong>Efficient State Management:</strong> Keep state local where possible and avoid lifting state unnecessarily.</li>
<li><strong>Avoid Inline Functions:</strong> Especially in props of frequently updating components.</li>
<li><strong>Debounce Input Handlers:</strong> Reduces update frequency in response to user typing or scroll events.</li>
<li><strong>Use Production Builds:</strong> Always deploy with optimized production build using <code>npm run build</code>.</li>
</ol>

<br><strong>Tools:</strong>
Use tools like React DevTools, Lighthouse, and Chrome Performance tab to identify performance bottlenecks.

</div></li>



<li data-id="q3"><span class="faq-question">---------------------------------------</span><br /><span class="faq-question">---------------------------------------</span></li>  


<li data-id="q_useCallback"><span class="faq-question">
useCallback() help performance?
</span><div class="answer">
<code>useCallback()</code> is a React hook that memoizes a function, preventing it from being re-created on every render unless its dependencies change. This improves performance, especially when passing callback functions to memoized child components, because it avoids unnecessary re-renders.
<br />
<b>Use Case:</b> When a child component receives a function as a prop and is wrapped with <code>React.memo</code>, using <code>useCallback</code> ensures that the function reference remains stable.

<b>Example:</b>
<pre><code>
const handleClick = useCallback(() =&gt; {
console.log('Button clicked');
}, []);
</code></pre>

This helps reduce render cycles and optimize React apps by maintaining stable function references.
</div></li>

<li data-id="q_useCallback_easy"><span class="faq-question">
useCallback() : Example
</span><div class="answer">
Here's a basic and easy-to-understand example of how <code>useCallback()</code> avoids unnecessary re-renders.

<pre><code>
// Parent.jsx
import React, { useState, useCallback } from 'react';
import Button from './Button';

const Parent = () =&gt; {
const [count, setCount] = useState(0);

const sayHello = useCallback(() =&gt; {
alert("Hello!");
}, []);

return (
&lt;div&gt;
&lt;p&gt;Count: {count}&lt;/p&gt;
&lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
&lt;Button onClick={sayHello} /&gt;
&lt;/div&gt;
);
};

export default Parent;

// Button.jsx
import React from 'react';

const Button = React.memo(({ onClick }) =&gt; {
console.log("Button rendered");
return &lt;button onClick={onClick}&gt;Say Hello&lt;/button&gt;;
});

export default Button;
</code></pre>

<b>Explanation:</b> Each time the count updates, <code>Parent</code> re-renders. Without <code>useCallback</code>, a new <code>sayHello</code> function would be created each time, causing <code>Button</code> to re-render too. With <code>useCallback</code>, the function reference stays the same, preventing the <code>Button</code> from unnecessary re-renders.
</div></li>

<li data-id="q_useCallback_dep"><span class="faq-question">
What is the second parameter [] in <code>useCallback(fn, [])</code>?
</span><div class="answer">
The second parameter in <code>useCallback(() =&gt; {...}, [])</code> is called the <b>dependency array</b>.

- An empty array <code>[]</code> means the callback function will be created once on the initial render and reused on every re-render.
- If any dependencies are listed inside the array (e.g., <code>[count]</code>), the function will only be re-created if those dependencies change.

<b>Example:</b>
<pre><code>
const sayHello = useCallback(() =&gt; {
alert("Hello!");
}, []); // No dependencies – function never re-created
</code></pre>

<b>Purpose:</b> Improves performance by avoiding unnecessary re-creation of functions unless specific values change.
</div></li>

<li data-id="q_useCallback_real"><span class="faq-question">
useCallback() : Example 02
</span><div class="answer">
Here’s a practical example of how <code>useCallback()</code> helps prevent unnecessary re-renders of child components that depend on callback props.

<pre><code>
// ParentComponent.jsx
import React, { useState, useCallback } from 'react';
import Child from './Child';

const Parent = () =&gt; {
const [count, setCount] = useState(0);

const handleClick = useCallback(() =&gt; {
console.log('Clicked!');
}, []);

return (
&lt;div&gt;
&lt;h2&gt;Count: {count}&lt;/h2&gt;
&lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
&lt;Child onClick={handleClick} /&gt;
&lt;/div&gt;
);
};

export default Parent;

// Child.jsx
import React from 'react';

const Child = React.memo(({ onClick }) =&gt; {
console.log('Child rendered');
return &lt;button onClick={onClick}&gt;Child Button&lt;/button&gt;;
});

export default Child;
</code></pre>

<b>Why this improves performance:</b><br>
Without <code>useCallback()</code>, the <code>handleClick</code> function gets re-created on each render, causing <code>Child</code> to re-render too. With <code>useCallback()</code>, the function is memoized and doesn’t change unless its dependencies change, preventing unnecessary renders.
</div></li>



<li data-id="q3"><span class="faq-question">---------------------------------------</span><br /><span class="faq-question">---------------------------------------</span></li>  


<li data-id="q_memory_cleanup"><span class="faq-question">
Memory Cleanup
</span><div class="answer">
Memory cleanup in React refers to the practice of releasing resources, subscriptions, and side effects when a component unmounts or re-renders, to avoid memory leaks.

<br><br><strong>Why it's important:</strong>
<ul>
<li>Prevents memory leaks.</li>
<li>Improves app performance and stability.</li>
<li>Avoids unwanted side effects.</li>
</ul>

<br><strong>Typical use case with <code>useEffect</code>:</strong>
<pre><code>
useEffect(() =&gt; {
const id = setInterval(() =&gt; {
console.log('Running interval...');
}, 1000);

return () =&gt; {
clearInterval(id); // cleanup
};
}, []);
</code></pre>

<br><strong>Other cleanup examples:</strong>
<ul>
<li><strong>WebSocket connections:</strong> Close them on unmount.</li>
<li><strong>Event listeners:</strong> Remove them using <code>removeEventListener</code>.</li>
<li><strong>Subscriptions:</strong> Unsubscribe to avoid multiple calls.</li>
</ul>

<br><strong>Key Tip:</strong> Always return a cleanup function inside <code>useEffect</code> to handle teardown properly.
<br /><br />
<strong>Prevents memory leaks:</strong> Cleaning up resources like timers, listeners, or network requests ensures your app doesn’t hold onto unused memory, avoiding gradual slowdowns or crashes.<br>
Memory leaks happen when resources like timers or event listeners persist after a component unmounts, causing increased memory use over time.<br>
<em>Example:</em> Forgetting to clear a <code>setInterval</code> keeps it running even when the component is gone.<br><br>


<strong>Improves app performance and stability:</strong> Proper cleanup reduces unnecessary work and resource consumption, making your app faster and more reliable.<br> Cleaning up avoids unnecessary processing and frees resources, helping the app run faster and reducing crashes.<br>
<em>Example:</em> Removing event listeners prevents them from firing needlessly.<br><br>


<strong>Avoids unwanted side effects:</strong> Stale or orphaned subscriptions can cause unexpected behavior; cleanup stops this by removing obsolete event handlers or data fetches. Side effects like duplicated API calls or event handling can cause bugs.<br>
<em>Example:</em> Multiple listeners causing repeated console logs.<br><br>


<strong>WebSocket connections:</strong> Close WebSocket connections on component unmount to prevent ongoing data streams and memory usage.<br><br>

<strong>Event listeners:</strong> Always remove event listeners with <code>removeEventListener</code> to avoid duplicated or lingering handlers.<br><br>



Proper cleanup ensures smooth, predictable app behavior and optimal resource use.

<br />




<strong>WebSocket connections:</strong> Always close WebSockets on unmount to stop receiving messages and free resources.<br>
<pre><code>useEffect(() =&gt; {
const ws = new WebSocket('wss://example.com');
ws.onmessage = event =&gt; console.log(event.data);
return () =&gt; ws.close();
}, []);</code></pre>

<strong>Event listeners:</strong> Add listeners on mount and remove on unmount.<br>
<pre><code>useEffect(() =&gt; {
const onScroll = () =&gt; console.log('scroll');
window.addEventListener('scroll', onScroll);
return () =&gt; window.removeEventListener('scroll', onScroll);
}, []);</code></pre>

<strong>Subscriptions:</strong> Unsubscribe from observables or data sources to prevent multiple triggers and memory leaks. Unsubscribe to avoid multiple triggers.<br>
<pre><code>useEffect(() =&gt; {
const subscription = someObservable.subscribe(data =&gt; console.log(data));
return () =&gt; subscription.unsubscribe();
}, []);</code></pre>

Cleaning up keeps React apps efficient and bug-free.
</div></li>


<li data-id="q_cleanup_example"><span class="faq-question">
Memory Cleanup : timers, listeners and network requests to prevent memory leaks
</span><div class="answer">
Here’s a React example showing how to clean up timers, event listeners, and fetch requests:

<pre><code>import React, { useEffect, useState } from 'react';

const CleanupExample = () =&gt; {
const [data, setData] = useState(null);

useEffect(() =&gt; {
// Timer setup
const timerId = setInterval(() =&gt; {
console.log('Timer tick');
}, 1000);

// Event listener setup
const handleResize = () =&gt; {
console.log('Window resized');
};
window.addEventListener('resize', handleResize);

// Network request with AbortController
const controller = new AbortController();
fetch('https://jsonplaceholder.typicode.com/posts/1', { signal: controller.signal })
.then(res =&gt; res.json())
.then(json =&gt; setData(json))
.catch(err =&gt; {
if (err.name === 'AbortError') {
console.log('Fetch aborted');
} else {
console.error(err);
}
});

// Cleanup function runs on component unmount
return () =&gt; {
clearInterval(timerId);             // Clear timer
window.removeEventListener('resize', handleResize); // Remove listener
controller.abort();                  // Abort fetch request
console.log('Cleaned up resources');
};
}, []);

return (
&lt;div&gt;
&lt;h3&gt;Data from API:&lt;/h3&gt;
&lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;
&lt;/div&gt;
);
};

export default CleanupExample;
</code></pre>

This prevents memory leaks by stopping timers, removing listeners, and aborting unfinished network requests when the component unmounts.
</div></li>


<li data-id="q_memory_cleanup_api_list"><span class="faq-question">
How to handle memory cleanup for an items list fetched from an API in React?
</span><div class="answer">
When fetching and displaying an items list from an API, it’s important to clean up resources like ongoing requests or subscriptions to prevent memory leaks.

<br><br><strong>Example using <code>axios</code> with cancellation:</strong>
<pre><code>
import React, { useEffect, useState } from 'react';
import axios from 'axios';

const ItemList = () =&gt; {
const [items, setItems] = useState([]);

useEffect(() =&gt; {
const source = axios.CancelToken.source();

axios.get('https://jsonplaceholder.typicode.com/posts', {
cancelToken: source.token
})
.then(res =&gt; setItems(res.data))
.catch(err =&gt; {
if(axios.isCancel(err)) {
console.log('Request canceled');
} else {
console.error(err);
}
});

return () =&gt; {
source.cancel('Component unmounted, request canceled');
};
}, []);

return (
&lt;ul&gt;
{items.map(item =&gt; (
&lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
))}
&lt;/ul&gt;
);
};

export default ItemList;
</code></pre>

<br><strong>Key points:</strong>
<ul>
<li>Use <code>axios.CancelToken</code> to cancel API requests if the component unmounts.</li>
<li>This prevents setting state on unmounted components, avoiding memory leaks and warnings.</li>
<li>Always clean up subscriptions or listeners similarly in <code>useEffect</code>.</li>
</ul>
</div></li>

<li data-id="q_memory_cleanup_fetch"><span class="faq-question">
Is memory cleanup possible with <code>fetch()</code> in React? How to do it?
</span><div class="answer">
Yes, memory cleanup with <code>fetch()</code> is possible by using the <code>AbortController</code> API to cancel ongoing requests when a component unmounts.

<br><br><strong>Example:</strong>
<pre><code>
import React, { useEffect, useState } from 'react';

const ItemList = () =&gt; {
const [items, setItems] = useState([]);

useEffect(() =&gt; {
const controller = new AbortController();
const signal = controller.signal;

fetch('https://jsonplaceholder.typicode.com/posts', { signal })
.then(response =&gt; response.json())
.then(data =&gt; setItems(data))
.catch(err =&gt; {
if (err.name === 'AbortError') {
console.log('Fetch aborted');
} else {
console.error(err);
}
});

return () =&gt; {
controller.abort(); // Cleanup: abort fetch on unmount
};
}, []);

return (
&lt;ul&gt;
{items.map(item =&gt; (
&lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
))}
&lt;/ul&gt;
);
};

export default ItemList;
</code></pre>

<br><strong>Summary:</strong>
<ul>
<li><code>AbortController</code> cancels fetch requests.</li>
<li>Prevents setting state after unmount, avoiding memory leaks.</li>
<li>Works similarly to cancellation tokens in libraries like axios.</li>
</ul>
</div></li>


<li data-id="q_lazyloading"><span class="faq-question">
    Lazy Loading
    </span><div class="answer">
    Lazy loading in React is a performance optimization technique that delays the loading of components until they are needed. It reduces the initial bundle size and improves app load time.
    
    <b>React provides:</b> <code>React.lazy()</code> and <code>Suspense</code> for lazy loading components.
    
    <b>Example:</b>
    <pre><code>
    // Lazy import
    const MyComponent = React.lazy(() => import('./MyComponent'));
    
    function App() {
      return (
        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
          &lt;MyComponent /&gt;
        &lt;/Suspense&gt;
      );
    }
    </code></pre>
    
    <b>Key Benefits:</b>
    <ul>
      <li>Faster initial load</li>
      <li>Code splitting</li>
      <li>Improved performance for large apps</li>
    </ul>
    </div></li>
    

<li data-id="q_virtualization"><span class="faq-question">
Virtualization
</span><div class="answer">
<strong>Virtualization</strong> in React refers to a performance optimization technique used to efficiently render long lists or large datasets by only rendering items visible in the viewport. Instead of rendering all items in the DOM, virtualization ensures that only a subset (visible + buffer) is rendered, improving load time and scroll performance.

<br><br><strong>Popular Libraries:</strong>
<ul>
<li><code>react-window</code></li>
<li><code>react-virtualized</code></li>
</ul>

<br><strong>Example:</strong>
Instead of rendering 10,000 rows at once, virtualization renders only, say, 30 at a time, reusing DOM elements as the user scrolls.

<br><br><strong>Benefits:</strong>
<ul>
<li>Improves rendering speed</li>
<li>Reduces memory usage</li>
<li>Enhances user experience with smooth scrolling</li>
</ul>

<br><strong>Use Case:</strong> Ideal for chat apps, data grids, tables, and infinite scroll UIs.
</div></li>

<li data-id="q_virtualization_api"><span class="faq-question">
How do you implement Virtualization with API data in a functional React component?
</span><div class="answer">

You can combine virtualization with API data by first fetching data and then rendering it using a virtualization library like <code>react-window</code>.

<br><br><strong>Step-by-step Example:</strong>
<pre><code>
import React, { useEffect, useState } from 'react';
import { FixedSizeList as List } from 'react-window';
import axios from 'axios';

const VirtualizedItemList = () =&gt; {
const [items, setItems] = useState([]);

useEffect(() =&gt; {
axios.get('https://jsonplaceholder.typicode.com/posts')
.then((res) =&gt; setItems(res.data))
.catch((err) =&gt; console.error(err));
}, []);

const Row = ({ index, style }) =&gt; (
&lt;div style={style}&gt;
&lt;strong&gt;{items[index]?.title}&lt;/strong&gt;
&lt;p&gt;{items[index]?.body}&lt;/p&gt;
&lt;/div&gt;
);

return (
&lt;div&gt;
&lt;h3&gt;Virtualized API Item List&lt;/h3&gt;
{items.length &gt; 0 &amp;&amp; (
&lt;List
height={400}
itemCount={items.length}
itemSize={80}
width={'100%'}
&gt;
{Row}
&lt;/List&gt;
)}
&lt;/div&gt;
);
};

export default VirtualizedItemList;
</code></pre>

<br><strong>Explanation:</strong>
<ul>
<li><code>axios</code> fetches data from the API.</li>
<li><code>FixedSizeList</code> renders only visible items.</li>
<li>Optimized for large lists with smooth scrolling.</li>
</ul>

</div></li>
















































<li data-id="q3"><span class="faq-question">---------------------------------------</span><br /><span class="faq-question">---------------------------------------</span></li>    



<li data-id="q_getderivedstatefromprops"><span class="faq-question">
    What is <code>getDerivedStateFromProps</code> in React?
    </span><div class="answer">
    <code>getDerivedStateFromProps</code> is a static lifecycle method in React class components that gets called right before rendering, both on the initial mount and on subsequent updates. It is used to update the component's state based on changes in props.
    <br />
    <b>Syntax:</b>
    <pre><code>
    static getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.value !== prevState.value) {
        return { value: nextProps.value };
      }
      return null;
    }
    </code></pre>
    
    <b>Use Cases:</b>
    <ol class="subul">
      <li>Sync internal state with props</li>
      <li>Reset state when props change</li>
    </ol>
    
    <b>Important Notes:</b>
    <ol class="subul">
      <li>It must return an object to update state or <code>null</code> to do nothing.</li>
      <li>Avoid side effects here—use it only for state updates.</li>
    </ol>
    
    </div></li>
    

<li data-id="q_onchange_vs_oninput"><span class="faq-question">
Difference between <code>onChange</code> and <code>onInput</code>?
</span><div class="answer">
In React, both <code>onChange</code> and <code>onInput</code> are event handlers for form elements, but they behave slightly differently:
<br />
<b>onChange:</b>
- Triggered when the input loses focus or the value changes.
- React wraps <code>onChange</code> to behave more like <code>onInput</code> (fires on every keystroke) for text inputs.
<br />
<b>onInput:</b>
- Triggered immediately after the value of an element changes.
- Fires for more input types like <code>range</code>, <code>color</code>, etc.
<br />
<b>In practice:</b> For text inputs, <code>onChange</code> and <code>onInput</code> behave similarly in React.

<pre><code>
// Example
&lt;input onChange={(e) =&gt; console.log("Change:", e.target.value)} /&gt;
&lt;input onInput={(e) =&gt; console.log("Input:", e.target.value)} /&gt;
</code></pre>

Use <code>onChange</code> in React forms as it's the standard for capturing user input.<br /><br /><br />


<b>When should we use <code>onChange</code> and when <code>onInput</code> in React?</b>

<b>Use <code>onChange</code> when:</b>
<ol class="subul">
<li>You are working with form elements like <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, or <code>&lt;select&gt;</code>.</li>
<li>You want to follow React's controlled component pattern.</li>
<li>You are managing form state (e.g., capturing user input in state).</li>
</ol>

<b>Use <code>onInput</code> when:</b>
<ol class="subul">
<li>You need more immediate, lower-level input events (e.g., for custom validation or live formatting).</li>
<li>You're working with input types like <code>range</code>, <code>color</code>, or other non-text fields where <code>onChange</code> may behave differently.</li>
</ol>

<b>Example:</b>
<pre><code>
&lt;!-- Standard form control --&gt;
&lt;input type="text" onChange={(e) =&gt; setValue(e.target.value)} /&gt;

&lt;!-- Live input handling (e.g., formatting) --&gt;
&lt;input type="text" onInput={(e) =&gt; handleFormat(e.target.value)} /&gt;
</code></pre>

In most React forms, <code>onChange</code> is the preferred and consistent choice.
</div></li>



<li data-id="q_error_boundaries"><span class="faq-question">
    What are Error Boundaries in React?
    </span><div class="answer">
    Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire app.
    
    <b>Use Case:</b> They prevent an entire React app from crashing due to an error in a specific part of the UI.
    
    <b>Implementing an Error Boundary:</b>
    <pre><code>
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }
    
      static getDerivedStateFromError(error) {
        return { hasError: true };
      }
    
      componentDidCatch(error, info) {
        console.error("Error caught:", error, info);
      }
    
      render() {
        if (this.state.hasError) {
          return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
        }
        return this.props.children;
      }
    }
    </code></pre>
    
    <b>Usage:</b>
    <pre><code>
    &lt;ErrorBoundary&gt;
      &lt;MyComponent /&gt;
    &lt;/ErrorBoundary&gt;
    </code></pre>
    
    <b>Note:</b> Error Boundaries only catch errors in render, lifecycle methods, and constructors of the child components—not in event handlers.
    </div></li>
    


<li data-id="q1"><span class="faq-question">
getStaticProps Vs getServerSideProps
</span><div class="answer">
getStaticProps?
Answer: Runs at build time to fetch data and pass it as props for static generation
<br />

getServerSideProps?
Answer: Runs on each request (server-side) to fetch data dynamically.

<br />
</div></li>


<li data-id="q1"><span class="faq-question">
What is ISR (Incremental Static Regeneration)?
</span><div class="answer">


Answer: Allows you to update static content after deployment without rebuilding the entire site.
export async function getStaticProps() {
return {
props: { ... },
revalidate: 10, // seconds
};
}

<br />
</div></li>




</ul>

<script src="htmlscript.js"></script>
</body>
</html>
