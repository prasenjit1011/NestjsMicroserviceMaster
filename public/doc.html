<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FAQ with Checkbox + Cookie</title>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.1/dist/js.cookie.min.js"></script>
<style>
body {
font-family: Arial, sans-serif;
padding: 2px;
background-color: #FFF;
}

ul.faq {
list-style-type: none;
padding: 0;
background-color: #FFF;
}

ul.faq li {
border-bottom: 1px solid #ddd;
padding: 10px 10px 1px 10px ;
cursor: pointer;
font-weight: bold;
background: #FFF;
transition: background 0.3s;
position: relative;
}

ul.faq li:hover {
background: #eef;
}

.answer {
display: none;
padding: 10px 10px 10px 30px;
background: #FFF;
color: #000;
border-left: 4px solid #007BFF;
font-weight: 500;
}

.faq-checkbox {
position: absolute;
left: 10px;
top: 12px;
}

.faq-question {
margin-left: 30px;
}
.d-none{
display: none;
}
</style>
</head>
<body>


<ul class="faq">
<li data-id="q1"><span class="faq-question">
Node.js?
</span><div class="answer">
Node.js is an open-source, cross-platform runtime built on Chrome’s V8 JavaScript engine that allows JavaScript to run outside the browser. It’s designed for building scalable, event-driven, non-blocking I/O applications, commonly used for servers and APIs.
</div></li>

<li data-id="q2"><span class="faq-question">
Event loop?
</span><div class="answer">
The event loop is a mechanism that handles asynchronous callbacks. It allows Node.js to perform non-blocking I/O operations by offloading tasks to the system kernel and executing their callbacks when ready, enabling efficient single-threaded concurrency.
</div></li>


<li data-id="q22"><span class="faq-question">
Event loop phases?
</span><div class="answer">
Phases include:  
1. timers  
2. pending callbacks  
3. idle/prepare  
4. poll  
5. check (for `setImmediate`)  
6. close callbacks  
Each handles specific queued callbacks.
</div></li>

<li data-id="q9"><span class="faq-question">
Handle concurrency if it's single-threaded?
</span><div class="answer">
Node.js uses the event loop and asynchronous I/O via the libuv library. Heavy tasks are delegated to worker threads or the OS, enabling multiple tasks to be processed concurrently.
</div></li>

<li data-id="q5"><span class="faq-question">
Callback?
</span><div class="answer">
A callback is a function passed as an argument to another function. It’s executed after the completion of an asynchronous operation, allowing non-blocking behavior in Node.js.
</div></li>
<li data-id="q8"><span class="faq-question">
Streams?
</span><div class="answer">
Streams are objects for reading or writing data continuously. They include readable, writable, duplex, and transform streams. Streams are memory-efficient and used for processing large data like files.
</div></li>

<li data-id="q13"><span class="faq-question">
Worker threads?
</span><div class="answer">
Worker threads enable running JavaScript in parallel threads. Unlike the main thread, they can handle CPU-intensive tasks without blocking the event loop, improving performance.
</div>
<div class="answer">
Worker threads are a way to run JavaScript code in parallel on multiple threads in Node.js. While Node.js is single-threaded by default (using an event loop), worker threads enable CPU-intensive tasks to be executed without blocking the main event loop, improving performance for compute-heavy operations.

Introduced in Node.js v10.5.0 (stable since v12), the <code>worker_threads</code> module allows you to create and manage threads that run scripts independently. Each worker has its own event loop, memory, and execution context, enabling true parallelism.

Use cases include heavy computations, data processing, or any synchronous tasks that would otherwise block the main thread and degrade app responsiveness.

Communication between the main thread and worker threads happens via messaging using <code>postMessage()</code> and listening to <code>message</code> events. Workers can share memory efficiently using <code>SharedArrayBuffer</code>.

Example usage:

<pre><code>const { Worker } = require('worker_threads');
const worker = new Worker('./workerScript.js');
worker.on('message', msg =&gt; console.log('From worker:', msg));
worker.postMessage('start');
</code></pre>

Worker threads complement Node.js’s asynchronous model by enabling parallel execution for heavy workloads while maintaining non-blocking I/O in the main thread.
</div></li>
<li data-id="q_package_lock"><span class="faq-question">
  Package-lock.json?
  </span><div class="answer">
  <code>package-lock.json</code> is automatically generated by npm when installing dependencies. It locks the exact versions of installed packages and their sub-dependencies to ensure consistency across different environments. While <code>package.json</code> defines dependency ranges (e.g., <code>^1.2.3</code>), <code>package-lock.json</code> stores the exact versions (e.g., <code>1.2.3</code>) used during installation.<br><br>
  
  This ensures that every developer or deployment environment installs the same dependency tree, avoiding bugs caused by version differences. It also improves performance by caching dependency metadata. This file should be committed to version control in most projects.
  </div></li>
  
<li data-id="q_node_error_handling"><span class="faq-question">
  Error handling?
  </span><div class="answer">
  Error handling in Node.js is critical for building reliable applications. Common strategies include:<br />
  
  <strong>1. Try-Catch:</strong> Used for synchronous code and <code>async/await</code> blocks.
  <pre><code>
  try {
    const data = await getData();
  } catch (err) {
    console.error(err.message);
  }
  </code></pre>
  
  <strong>2. Error-First Callbacks:</strong> Standard Node pattern where the first parameter is an error object.
  <pre><code>
  fs.readFile('file.txt', (err, data) => {
    if (err) return console.error(err);
    console.log(data.toString());
  });
  </code></pre>
  
  <strong>3. Global Error Handling:</strong> Catch unhandled exceptions or promise rejections.
  <pre><code>
  process.on('uncaughtException', (err) => {
    console.error('Unhandled Exception:', err);
  });
  process.on('unhandledRejection', (reason) => {
    console.error('Unhandled Rejection:', reason);
  });
  </code></pre>
  
  <strong>4. Express Middleware:</strong> Use error-handling middleware in Express.
  <pre><code>
  app.use((err, req, res, next) => {
    res.status(500).json({ message: err.message });
  });
  </code></pre>
  
  Proper error handling helps maintain app stability and improves debugging.
  </div></li>
  


<li data-id="q14"><span class="faq-question">
Middleware?
</span><div class="answer">
Middleware in Express.js is a function that processes requests and responses during the request-response cycle. It has access to the <code>req</code> and <code>res</code> objects and the next middleware function in the stack via the <code>next()</code> callback.

Middleware functions can perform tasks like:
<ul>
<li>Executing code</li>
<li>Modifying <code>req</code> and <code>res</code> objects</li>
<li>Ending the request-response cycle</li>
<li>Calling the next middleware</li>
</ul>

Types of middleware include:
<ul>
<li><strong>Application-level:</strong> Bound to an Express app using <code>app.use()</code> or route methods.</li>
<li><strong>Router-level:</strong> Bound to an instance of <code>express.Router()</code>.</li>
<li><strong>Error-handling:</strong> Special middleware with four arguments <code>(err, req, res, next)</code> to catch errors.</li>
<li><strong>Built-in:</strong> Provided by Express, e.g., <code>express.json()</code>, <code>express.static()</code>.</li>
<li><strong>Third-party:</strong> Such as <code>cors</code>, <code>helmet</code>, <code>morgan</code>.</li>
</ul>

Example:

<pre><code>app.use((req, res, next) =&gt; {
console.log('Request URL:', req.url);
next(); // Pass control to next middleware
});
</code></pre>

Middleware enables modular, reusable, and organized handling of HTTP requests, essential for building scalable Express.js applications.
</div></li>


<li data-id="q19"><span class="faq-question">
Clustering?
</span><div class="answer">
Clustering enables using multiple CPU cores by spawning worker processes that share the same server port, improving performance and load handling.
</div>
<div class="answer">
Clustering in Node.js is a technique to create multiple child processes (workers) that share the same server port, allowing you to take advantage of multi-core CPU systems. Since Node.js runs on a single thread by default, clustering helps improve performance and reliability by distributing incoming requests across several worker processes.

The core module <code>cluster</code> enables spawning of worker processes. Each worker runs its own event loop and instance of the Node.js runtime, enabling parallel processing of requests.

Key benefits:
<ul>
<li><strong>Improved Performance:</strong> Utilizes multiple CPU cores to handle more concurrent connections.</li>
<li><strong>Fault Tolerance:</strong> If one worker crashes, the master process can spawn a new worker, improving app resilience.</li>
<li><strong>Load Balancing:</strong> The master process balances incoming requests between workers.</li>
</ul>

Basic usage example:

<pre><code>const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
for (let i = 0; i < numCPUs; i++) {
cluster.fork();
}
cluster.on('exit', (worker) => {
console.log(`Worker ${worker.process.pid} died, spawning a new one.`);
cluster.fork();
});
} else {
http.createServer((req, res) =&gt; {
res.end('Hello from worker ' + process.pid);
}).listen(8000);
}
</code></pre>

Clustering boosts Node.js scalability but requires careful management of shared resources and state.
</div>

</li>


<li data-id="q28"><span class="faq-question">
Optimize performance in a large-scale Node.js app?
</span><div class="answer">
Use clustering, caching (Redis), async operations, database indexing, code profiling, monitoring (e.g., New Relic), and limit synchronous code. Minimize memory leaks and optimize queries.
</div>
<div class="answer">
Optimizing performance in large-scale Node.js applications involves multiple strategies:

<strong>1. Use Asynchronous Code:</strong> Always prefer non-blocking async operations to avoid blocking the event loop.<br>

<strong>2. Load Balancing & Clustering:</strong> Use the <code>cluster</code> module or external load balancers to utilize multiple CPU cores.<br>

<strong>3. Caching:</strong> Cache frequent data using in-memory stores like Redis or Memcached to reduce database load.<br>

<strong>4. Database Optimization:</strong> Use indexing, connection pooling, and optimized queries to improve database interaction.<br>

<strong>5. Avoid Memory Leaks:</strong> Monitor heap usage, manage object lifecycles carefully, and use profiling tools like Chrome DevTools or Clinic.js.<br>

<strong>6. Use Streams:</strong> Process large data efficiently with streams to minimize memory footprint.<br>

<strong>7. Efficient Logging:</strong> Use asynchronous logging libraries and avoid excessive logging in production.<br>

<strong>8. Minimize Dependencies:</strong> Avoid bloated or unused npm packages to reduce startup time.<br>

<strong>9. Profiling & Monitoring:</strong> Continuously profile your app using tools like New Relic, Datadog, or built-in profilers.<br>

<strong>10. Use CDN & Compression:</strong> Serve static assets via CDN and compress responses with gzip or brotli.<br>

Regular code reviews, performance testing, and keeping dependencies up-to-date help maintain high performance.
</div>

</li>

<li data-id="q12"><span class="faq-question">
Difference between process.nextTick() and setImmediate()?
</span><div class="answer">
<code>process.nextTick()</code> schedules a callback to execute immediately after the current operation completes, before the event loop continues. It has higher priority and runs before any I/O events or timers.<br><br>

<code>setImmediate()</code> schedules a callback to run on the next iteration (tick) of the event loop, after I/O events callbacks.<br><br>

In short, <code>process.nextTick()</code> runs before any I/O tasks, while <code>setImmediate()</code> runs after I/O events in the event loop. Overusing <code>process.nextTick()</code> can starve I/O, blocking the event loop.
</div></li>

<li data-id="q24"><span class="faq-question">
How do you secure a Node.js application?
</span><div class="answer">
Securing a Node.js application involves multiple layers of protection:<br />

<strong>1. HTTP Headers:</strong> Use <code>helmet</code> middleware to set secure HTTP headers and prevent common attacks like XSS, clickjacking, and MIME-sniffing.<br>

<strong>2. Rate Limiting:</strong> Implement request throttling using <code>express-rate-limit</code> to protect against brute-force and DDoS attacks.<br>

<strong>3. Input Validation & Sanitization:</strong> Use libraries like <code>express-validator</code> or <code>Zod</code> to validate and sanitize incoming data to avoid injection attacks.<br>

<strong>4. Authentication & Authorization:</strong> Use secure token-based auth like <code>JWT</code>. Never store sensitive info in plain text—always hash passwords with <code>bcrypt</code>.<br>

<strong>5. Use HTTPS:</strong> Encrypt communication using SSL certificates to secure data in transit.<br>

<strong>6. Avoid Eval & Unsafe Code:</strong> Never use <code>eval()</code> or <code>Function()</code> with untrusted data. These can lead to RCE (Remote Code Execution).<br>

<strong>7. Dependency Management:</strong> Use <code>npm audit</code> and tools like <code>snyk</code> to identify and fix vulnerable packages.<br>

<strong>8. Secure Cookies:</strong> Use <code>HttpOnly</code>, <code>Secure</code>, and <code>SameSite</code> flags on cookies.<br>

<strong>9. Environment Variables:</strong> Keep secrets and configs in <code>.env</code> files. Never hard-code credentials.<br>

<strong>10. Logging & Monitoring:</strong> Monitor with tools like <code>Winston</code>, <code>Morgan</code>, or services like Datadog or New Relic.

Regularly update Node.js and dependencies to stay protected.
</div></li>


<li data-id="q20"><span class="faq-question">
Explain how Buffer works in Node.js.
</span><div class="answer">
`Buffer` is a global object used to handle binary data directly. It's useful for working with streams, files, and network protocols without converting to strings.
</div></li>


<li data-id="q_ts"><span class="faq-question">
TypeScript?
</span><div class="answer">
TypeScript is a strongly typed superset of JavaScript developed by Microsoft. It adds static typing, interfaces, enums, and advanced tooling features to JavaScript, helping developers catch errors at compile time instead of runtime. TypeScript code compiles down to plain JavaScript, making it compatible with any environment that runs JS. It improves code quality, readability, and maintainability, especially for large-scale applications. TypeScript integrates well with modern frameworks like Angular, React, and Node.js, and offers excellent support in popular editors like VS Code with features like autocompletion and refactoring.
</div></li>

<li data-id="q_gql"><span class="faq-question">
GraphQL?
</span><div class="answer">
GraphQL offers several advantages over traditional REST APIs:
<ul>
<li><strong>Flexible Queries:</strong> Clients can request exactly the data they need, reducing over-fetching and under-fetching.</li>
<li><strong>Single Endpoint:</strong> All data queries and mutations happen through one endpoint, simplifying API management.</li>
<li><strong>Strongly Typed Schema:</strong> The schema defines the types and relationships, enabling better validation and tooling.</li>
<li><strong>Efficient Data Loading:</strong> Supports batching and caching to minimize redundant data fetching.</li>
<li><strong>Improved Developer Experience:</strong> Introspection and auto-generated documentation make development faster and easier.</li>
<li><strong>Real-time Data:</strong> Supports subscriptions for live updates.</li>
</ul>
These features make GraphQL ideal for complex, evolving APIs and frontend-driven development.
</div></li>

<li data-id="q_react_state"><span class="faq-question">
What is state in React?
</span><div class="answer">
State in React is an object that holds dynamic data for a component. It determines how the component behaves and renders. When the state changes, React automatically re-renders the component to reflect the new data. State is managed within the component (using <code>useState</code> in functional components) and should be updated using the provided setter function to ensure proper reactivity.

</div></li>

<li data-id="q_react_vs_next"><span class="faq-question">
What is the difference between React.js and Next.js?
</span><div class="answer">
<strong>React.js</strong> is a JavaScript library for building user interfaces, mainly focused on the frontend. It offers a component-based approach and handles client-side rendering but doesn’t include built-in routing or server-side rendering.

<strong>Next.js</strong> is a React framework that extends React by adding powerful features like:
<ul>
<li>File-based routing</li>
<li>Server-side rendering (SSR)</li>
<li>Static site generation (SSG)</li>
<li>API routes</li>
<li>SEO optimization</li>
</ul>
While React provides the foundation for UI, Next.js offers a complete solution for building full-stack applications with better performance and scalability.
</div></li>

<li data-id="q_react_memory_virtualization"><span class="faq-question">
What is memory cleanup and virtualization in React.js?
</span><div class="answer">
<strong>Memory Cleanup:</strong> In React, memory cleanup is often done using the <code>useEffect</code> hook’s cleanup function. It prevents memory leaks by cleaning up subscriptions, timers, or event listeners when a component unmounts or before re-running the effect.

Example:
<pre><code>
useEffect(() => {
const timer = setInterval(() => console.log('Tick'), 1000);
return () => clearInterval(timer); // Cleanup
}, []);
</code></pre>

<strong>Virtualization:</strong> Virtualization improves performance by rendering only the visible portion of large lists instead of the entire list. Libraries like <code>react-window</code> or <code>react-virtualized</code> help with this.

Example with <code>react-window</code>:
<pre><code>
import { FixedSizeList as List } from 'react-window';

&lt;List height={400} itemCount={1000} itemSize={35} width={300}&gt;
{({ index, style }) =&gt; &lt;div style={style}&gt;Item {index}&lt;/div&gt;}
&lt;/List&gt;
</code></pre>

This boosts performance and reduces memory usage in large UIs.
</div></li>
<li data-id="q_design_patterns"><span class="faq-question">
  What are design patterns in Node.js?
  </span><div class="answer">
  Design patterns are reusable solutions to common software design problems. In Node.js, popular patterns include:<br />
  
  <strong>1. Singleton:</strong> Ensures a class has only one instance (e.g., database connection).<br>
  <strong>2. Factory:</strong> Creates objects without exposing the instantiation logic.<br>
  <strong>3. Observer:</strong> Implements pub-sub mechanisms (e.g., <code>EventEmitter</code>).<br>
  <strong>4. Middleware:</strong> Common in Express apps for request handling.<br>
  <strong>5. Module Pattern:</strong> Uses closures to encapsulate logic.
  
  Using design patterns improves code organization, reusability, and maintainability in scalable Node.js applications.
  </div></li>
  <li data-id="q_design_patterns_more"><span class="faq-question">
    Explain Singleton, Factory, Observer, Middleware, and Module patterns in Node.js
    </span><div class="answer">
    <strong>Singleton:</strong> Restricts a class to one instance. Useful for shared resources like DB connections. Ensures consistent state across the app.<br><br>
    
    <strong>Factory:</strong> Creates objects without specifying exact classes. It abstracts object creation, allowing flexible and interchangeable products.<br><br>
    
    <strong>Observer:</strong> Implements event-driven communication where objects subscribe to events and get notified on changes. Node’s <code>EventEmitter</code> is a classic example.<br><br>
    
    <strong>Middleware:</strong> Functions that intercept requests in a chain to process or modify them. Common in Express.js for logging, authentication, or error handling.<br><br>
    
    <strong>Module Pattern:</strong> Uses closures to encapsulate private variables and expose a public API. Helps in organizing code into reusable, maintainable parts.<br><br>
    
    These patterns help write modular, scalable, and maintainable Node.js applications.
    </div></li>
    










































<li data-id="q3"><span class="faq-question">---------------------------------------</span></li>    
<li data-id="q3"><span class="faq-question">
What are the key features of Node.js?
</span><div class="answer">
Key features include asynchronous and event-driven architecture, single-threaded model, fast execution via V8 engine, non-blocking I/O, npm (Node package manager), and the ability to build scalable network applications.
</div></li>

<li data-id="q4"><span class="faq-question">
Difference between require() and import?
</span><div class="answer">
`require()` is CommonJS syntax used in Node.js; it loads modules synchronously. `import` is ES6 syntax, used with modules, supports static analysis, and is asynchronous. `import` requires `"type": "module"` in `package.json`.
</div></li>


<li data-id="q6"><span class="faq-question">
non-blocking I/O?
</span><div class="answer">
Non-blocking I/O allows Node.js to continue executing other code while waiting for I/O operations (like reading files or querying databases) to complete, improving efficiency and scalability.
</div></li>

<li data-id="q7"><span class="faq-question">
How do you handle asynchronous code in Node.js?
</span><div class="answer">
Asynchronous code can be handled using callbacks, Promises, or `async/await`. These techniques prevent blocking the event loop and ensure smooth execution of concurrent tasks.
</div></li>




<li data-id="q10"><span class="faq-question">
the purpose of package.json?
</span><div class="answer">
`package.json` holds metadata about a Node.js project, including dependencies, scripts, version, main file, and more. It helps manage packages and project configuration.
</div></li>

<li data-id="q11"><span class="faq-question">
Explain the EventEmitter in Node.js.
</span><div class="answer">
`EventEmitter` is a core Node.js module that facilitates communication via events. You can create custom events using `emit()` and subscribe using `on()` or `once()`.
</div></li>







<li data-id="q15"><span class="faq-question">
How do you implement authentication in Node.js (e.g., JWT)?
</span><div class="answer">
Use `jsonwebtoken` to issue and verify JWT tokens. On login, generate a token and send it to the client. For protected routes, use middleware to verify the token.
</div></li>

<li data-id="q16"><span class="faq-question">
What are memory leaks in Node.js and how can you prevent them?
</span><div class="answer">
Memory leaks occur when memory is not released. Common causes include unused references, event listeners, or closures. Use tools like `clinic`, `heapdump`, and `--inspect` to detect and prevent them.
</div></li>

<li data-id="q17"><span class="faq-question">
How do you manage environment variables in Node.js?
</span><div class="answer">
Use `.env` files with the `dotenv` package. Load variables using `require('dotenv').config()` and access them via `process.env.VARIABLE_NAME`.
</div></li>

<li data-id="q18"><span class="faq-question">
the difference between spawn(), exec(), and fork()?
</span><div class="answer">
- `spawn()`: launches a new process, streams output.  
- `exec()`: buffers entire output in memory.  
- `fork()`: spawns a new Node.js process with IPC for communication.
</div></li>




<li data-id="q21"><span class="faq-question">
How does Node.js handle async I/O under the hood (libuv)?
</span><div class="answer">
libuv is a C library that manages thread pool and async I/O. It delegates I/O operations to the OS or internal threads and notifies Node.js when operations complete.
</div></li>



<li data-id="q23"><span class="faq-question">
backpressure in Node.js streams and how to handle it?
</span><div class="answer">
Backpressure occurs when the writable stream can't handle the data speed of a readable stream. Use `stream.pause()`, `drain` events, and `pipe()` for flow control.
</div></li>


<li data-id="q25"><span class="faq-question">
Explain process-level error handling (uncaughtException, unhandledRejection).
</span><div class="answer">
`process.on('uncaughtException')` and `process.on('unhandledRejection')` catch unhandled errors globally. Prefer local error handling; use these for logging and graceful shutdowns.
</div></li>

<li data-id="q26"><span class="faq-question">
How to implement custom events using EventEmitter?
</span><div class="answer">
Create an `EventEmitter` instance, emit events using `.emit('eventName', data)`, and listen using `.on('eventName', callback)`. Useful for decoupling logic.
</div></li>

<li data-id="q27"><span class="faq-question">
What are the differences between microservices and monoliths in a Node.js context?
</span><div class="answer">
Monoliths bundle all logic in one app. Microservices split features into independent services communicating via APIs or messages. Microservices are scalable, but complex to manage.
</div></li>



<li data-id="q29"><span class="faq-question">
Explain the concept of middleware chaining in Express.js.
</span><div class="answer">
Middleware chaining lets multiple functions process a request sequentially. Each middleware calls `next()` to pass control. Useful for validations, authentication, and logging.
</div></li>

<li data-id="q30"><span class="faq-question">
a memory heap and how do you analyze it in Node.js?
</span><div class="answer">
A memory heap is the area where memory is allocated for objects. Analyze it using Chrome DevTools, Node.js `--inspect` flag, or memory profiling tools like `heapdump`.
</div></li>

</ul>

<script>
$(document).ready(function () {
// Load checkbox states from cookies
$('.faq li').each(function () {
const id = $(this).data('id');
const isChecked = Cookies.get(id) === 'true';
$(this).find('.faq-checkbox').prop('checked', isChecked);
if (isChecked) {
$(this).find('.answer').show();
}
});

// On checkbox change: save state + show/hide answer
$('.faq-checkbox').change(function (e) {
e.stopPropagation(); // prevent parent <li> click
const parentLi = $(this).closest('li');
const id = parentLi.data('id');
const isChecked = $(this).is(':checked');
Cookies.set(id, isChecked, { expires: 365 }); // 1-year expiry

if (isChecked) {
parentLi.find('.answer').slideDown();
} else {
parentLi.find('.answer').slideUp();
}
});

// On question text click: toggle answer (not checkbox)
$('.faq-question').click(function () {
const parentLi = $(this).closest('li');
const answer = parentLi.find('.answer');
answer.slideToggle();
});
});
</script>

</body>
</html>
